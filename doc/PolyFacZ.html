<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta name="generator" content="Muse">
    <meta http-equiv="Content-Type"
          content="text/html; charset=gb2312">
    <link rel="stylesheet" type="text/css" charset="gb2312" media="all"
          href="../main.css" >
    <link rel="shortcut icon" href="../favicon.ico" type="image/vnd.microsoft.icon">
    <script type="text/javascript" charset="gb2312" src="../main.js"></script>
    <title>整系数多项式因子分解 - maTH&mu; - 计算机代数系统</title>
  </head>
  <body>
<div id="banner"></div><!-- banner -->    
<div id="header">
    <h1>整系数多项式因子分解
  </h1>
  <a name="top"></a>
  <div id="tab">
  <ul>
    <li><a href="../index.html" title="主页"><span>主页</span></a></li>
    <li><a href="../Doc.html" title="文档"><span>文档</span></a></li>
    <li><a href="../Dev.html" title="开发"><span>开发</span></a></li>
    <li><a href="http://groups.google.com/group/maTHmU?hl=zh-CN" title="论坛"><span>论坛</span></a></li>
    <li><a href="../JoinUs.html" title="加入我们"><span>加入我们</span></a></li>
  </ul>
  </div><!-- tab -->
</div><!-- header -->
<div id="container">
  <div id="body">
    <div id="leftshadow">
      <div id="page"> 
 <!-- Page published by Emacs Muse begins here -->
<a href="#" onClick="ShowHide(content)">隐藏目录</a>
<div id="content" class="contents">
<dl>
  <dt>
    <a href="#sec1">大素数模方法和因子组合(Factor Combination)算法</a>
  </dt>
  <dt>
    <a href="#sec2">Hensel提升(lifting)理论</a>
  </dt>
  <dt>
    <a href="#sec3">应用Hensel提升的Zasenhaus算法</a>
  </dt>
  <dt>
    <a href="#sec4">格中短向量(Short vectors in lattices)理论</a>
  </dt>
  <dd>
    <dl>
      <dt>
	<a href="#sec5">问题的引入</a>
      </dt>
      <dt>
	<a href="#sec6">约化基算法</a>
      </dt>
      <dt>
	<a href="#sec7">约化基算法的一些细节说明</a>
      </dt>
    </dl>
  </dd>
  <dt>
    <a href="#sec8">应用格中短向量的分解算法</a>
  </dt>
</dl>
</div>

<p>事实上我们可以讨论UFD及其分式域上的多项式，但下面我们仅限于讨论<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">和<img src="./latex/latex2png-PolyFacZ_40916048_-3.gif" alt="$\mathbb{Q}$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">上的多项式。由相关的高等代数学的知识，我们知道对于<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上的多项式<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">，其在<img src="./latex/latex2png-PolyFacZ_27044295_-5.gif" alt="$\mathbb{Q}[x]$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">中的不可约因子分解可对应于在<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">中的不可约因子分解，即若<img src="./latex/latex2png-PolyFacZ_125876513_.gif" alt="$$f=f_1f_2\cdots f_r(f_i\in\mathbb{Q}[x]),$$" class="latex-display" width="580" height="18">则有<img src="./latex/latex2png-PolyFacZ_231090265_.gif" alt="$$f=f_1'f_2'\cdots f_r'(f_i'\in\mathbb{Z}[x]).$$" class="latex-display" width="580" height="19">于是<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上任一多项式<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的因子分解对应于<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">上的因子分解和<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上本原多项式的因子分解。前者在素数理论中讨论，这里我们只讨论后者。</p>

<p>很自然的，由前面的最大公因子模方法我们可以想到用模方法来求解因子分解问题。首先我们可以利用上一章中的无平方因子分解的方法得到<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上的无平方因子本原多项式<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,这时，我们会遇到如下一些问题：</p>

<ol>
<li>素数<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">的选取要足够大，以使我们能从<img src="./latex/latex2png-PolyFacZ_255142917_-4.gif" alt="$f \bmod p$" class="latex-inline" style="vertical-align: -4px" width="58" height="16">得到<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,这一点我们可由模公因子算法中介绍的Mignotte界理论得到。</li>

<li>虽然<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">已是无平方因子，但<img src="./latex/latex2png-PolyFacZ_255142917_-4.gif" alt="$f \bmod p$" class="latex-inline" style="vertical-align: -4px" width="58" height="16">却不一定是无平方因子的。如多项式<img src="./latex/latex2png-PolyFacZ_185128288_-4.gif" alt="$f=x^2+5x+4$" class="latex-inline" style="vertical-align: -4px" width="114" height="18">无平方因子，但<img src="./latex/latex2png-PolyFacZ_42872535_-5.gif" alt="$f \bmod 3=x^2+2x+1=(x+1)^2$" class="latex-inline" style="vertical-align: -5px" width="242" height="19">.那么在随机选取素数<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">的时候如何使得<img src="./latex/latex2png-PolyFacZ_255142917_-4.gif" alt="$f \bmod p$" class="latex-inline" style="vertical-align: -4px" width="58" height="16">也是无平方因子呢？这一点在结式理论和后文中回答.</li>

<li>当我们在<img src="./latex/latex2png-PolyFacZ_71410771_-5.gif" alt="$\mathbb{Z}_p[x]$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">中将多项式分解后，如何将<img src="./latex/latex2png-PolyFacZ_255142917_-4.gif" alt="$f \bmod p$" class="latex-inline" style="vertical-align: -4px" width="58" height="16">的分解对应到<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的分解。最简单的方法是尝试每一种可能的因子组合。因为若<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">有不可约分解<img src="./latex/latex2png-PolyFacZ_195247501_-4.gif" alt="$f=f_1f_2\cdots f_r$" class="latex-inline" style="vertical-align: -4px" width="101" height="16">,则<img src="./latex/latex2png-PolyFacZ_257456434_-4.gif" alt="$\overline{f}=\overline{f_1}\cdots\overline{f_r}$" class="latex-inline" style="vertical-align: -4px" width="89" height="19">,但<img src="./latex/latex2png-PolyFacZ_89126981_-4.gif" alt="$\overline{f_i}$" class="latex-inline" style="vertical-align: -4px" width="14" height="19">不一定不可约。当然，用这种尝试的方法有时效率很低，因此后面还要介绍一种格中短向量(short vectors in lattices)方法。</li>
</ol>

<p>综上，我们首先要进入<img src="./latex/latex2png-PolyFacZ_71410771_-5.gif" alt="$\mathbb{Z}_p[x]$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">中求得因子分解，这一步我们可以利用“大素数”方法和“小素数”方法，只是这里的小素数不再是各不相同的素数，而是素数幂。第二步是由<img src="./latex/latex2png-PolyFacZ_71410771_-5.gif" alt="$\mathbb{Z}_p[x]$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">返回<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">中，求得最终结果，可以用尝试因子组合的方法和格中短向量方法.</p>

<h2><a name="sec1" id="sec1"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>大素数模方法和因子组合(Factor Combination)算法</h2>

<div class="definition">
<span class="theorem-header">定义1<a name=""></a></span><span class="theorem-name"></span>
对于<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$F$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">上多项式<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,定义其判别式为<img src="./latex/latex2png-PolyFacZ_208890063_-5.gif" alt="$\mathrm{disc}(f)=\mathrm{res}(f,f')$" class="latex-inline" style="vertical-align: -5px" width="136" height="18">.


</div>

<p>由推论<a class="ref-th-external" href="PolyFacZp.html#cor:squarefree1">1</a>知，<img src="./latex/latex2png-PolyFacZ_66731070_-4.gif" alt="$\overline{f}=f\bmod p$" class="latex-inline" style="vertical-align: -4px" width="91" height="19">是无平方因子的当且仅当<img src="./latex/latex2png-PolyFacZ_192478894_-5.gif" alt="$\mathrm{disc}(\overline{f})\neq 0$" class="latex-inline" style="vertical-align: -5px" width="81" height="20">.</p>

<div class="lemma">
<span class="theorem-header">引理1<a name=""></a></span><span class="theorem-name"></span>
<img src="./latex/latex2png-PolyFacZ_40465426_6.gif" alt="$'$" class="latex-inline" style="vertical-align: 6px" width="4" height="7">表示形式微商，则有<img src="./latex/latex2png-PolyFacZ_120921747_-4.gif" alt="$\overline{f'}=\overline{f}'$" class="latex-inline" style="vertical-align: -4px" width="51" height="22">.


</div>

<div class="theorem">
<span class="theorem-header">定理1<a name=""></a></span><span class="theorem-name"></span>
令<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">是一非零无平方因子多项式,<img src="./latex/latex2png-PolyFacZ_197100240_-4.gif" alt="$p\in\mathbb{N}$" class="latex-inline" style="vertical-align: -4px" width="42" height="16">是一个素数且<img src="./latex/latex2png-PolyFacZ_119044137_-5.gif" alt="$p\not |\mathrm{lc}(f)$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">,则<img src="./latex/latex2png-PolyFacZ_212247402_-4.gif" alt="$\overline{f}$" class="latex-inline" style="vertical-align: -4px" width="10" height="19">是无平方因子的当且仅当<img src="./latex/latex2png-PolyFacZ_151982317_-5.gif" alt="$p\not |\mathrm{disc}(f)$" class="latex-inline" style="vertical-align: -5px" width="72" height="18">.


</div>

<div class="proof">
<span class="proof-header">证明</span>
<img src="./latex/latex2png-PolyFacZ_212247402_-4.gif" alt="$\overline{f}$" class="latex-inline" style="vertical-align: -4px" width="10" height="19">无平方因子<img src="./latex/latex2png-PolyFacZ_73776598_-5.gif" alt="$\Leftrightarrow\mathrm{disc}(\overline{f})\neq 0\Leftrightarrow\mathrm{res}(\overline{f},\overline{f}')\neq 0$" class="latex-inline" style="vertical-align: -5px" width="223" height="23">,再由上面引理知:<img src="./latex/latex2png-PolyFacZ_247191228_.gif" alt="$$\mathrm{res}(\overline{f},\overline{f}')\neq 0\Leftrightarrow\mathrm{res}(\overline{f},\overline{f'})\neq 0.$$" class="latex-display" width="580" height="23">

<p>又<img src="./latex/latex2png-PolyFacZ_119044137_-5.gif" alt="$p\not |\mathrm{lc}(f)$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">,则由引理<a class="ref-th-external" href="PolyGCD.html#le:resultant2">2</a>知<img src="./latex/latex2png-PolyFacZ_93514548_.gif" alt="$$\mathrm{res}(\overline{f},\overline{f'})\neq 0\Leftrightarrow\overline{\mathrm{res}(f,f')}\neq 0\Leftrightarrow p\not |\mathrm{disc}(f).$$" class="latex-display" width="580" height="21"></p>

<p>证毕。
<span class="proof-end">□</span></p>

</div>

<p>由于<img src="./latex/latex2png-PolyFacZ_6360601_-5.gif" alt="$\mathrm{lc}(f)|\mathrm{res}(f,f')$" class="latex-inline" style="vertical-align: -5px" width="102" height="18">,则我们有下面的：</p>

<div class="corollary">
<span class="theorem-header">推论1<a name=""></a></span><span class="theorem-name"></span>
<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">是<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上非零无平方因子多项式，则<img src="./latex/latex2png-PolyFacZ_212247402_-4.gif" alt="$\overline{f}$" class="latex-inline" style="vertical-align: -4px" width="10" height="19">无平方因子当且仅当<img src="./latex/latex2png-PolyFacZ_178027072_-5.gif" alt="$p\not |\mathrm{disc}(f)=\mathrm{res}(f,f')\in\mathbb{Z}\setminus \{0\}$" class="latex-inline" style="vertical-align: -5px" width="230" height="18">.


</div>

<p>假设有<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上本原多项式<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的分解<img src="./latex/latex2png-PolyFacZ_195706253_-4.gif" alt="$f=f_1f_2\cdots f_k$" class="latex-inline" style="vertical-align: -4px" width="102" height="16">,且在模<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">下有：<img src="./latex/latex2png-PolyFacZ_229780857_.gif" alt="$$\overline{f}=\overline{f_1}\overline{f_2}\cdots\overline{f_k}=\overline{\mathrm{lc}(f)}g_1g_2\cdots g_r,$$" class="latex-display" width="580" height="21">其中<img src="./latex/latex2png-PolyFacZ_87258132_-4.gif" alt="$g_i$" class="latex-inline" style="vertical-align: -4px" width="13" height="12">为<img src="./latex/latex2png-PolyFacZ_223283783_-5.gif" alt="$\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="35" height="18">上首一不可约多项式.若<img src="./latex/latex2png-PolyFacZ_186938388_-5.gif" alt="$p/2$" class="latex-inline" style="vertical-align: -5px" width="25" height="18">比Mignotte界<img src="./latex/latex2png-PolyFacZ_221587875_-5.gif" alt="$(n+1)^{1/2}2^n|\mathrm{lc}(f)|\cdot\|f\|_{\infty}$" class="latex-inline" style="vertical-align: -5px" width="184" height="20">小,则有下面的等式：<img src="./latex/latex2png-PolyFacZ_141666051_.gif" alt="$$\frac{\mathrm{lc}(f)}{\mathrm{lc}(f_1)}f_1=\mathrm{lc}(f)\prod_{i\in S}g_i\in\mathrm{Z}[x],$$" class="latex-display" width="580" height="46">该式原先在<img src="./latex/latex2png-PolyFacZ_88908883_-5.gif" alt="$\mathrm{Z}_p[x]$" class="latex-inline" style="vertical-align: -5px" width="34" height="18">上就已成立了.其中指标集<img src="./latex/latex2png-PolyFacZ_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13">为<img src="./latex/latex2png-PolyFacZ_5390503_-5.gif" alt="$S=\{i\in\{1,\ldots,r\}|g_i|\overline{f_1}\}$" class="latex-inline" style="vertical-align: -5px" width="182" height="20">.</p>

<div class="algorithm">
<span class="theorem-header">算法1<a name="al:bpfc1"></a></span><span class="theorem-name">(整系数多项式因子分解1:大素数和因子组合方法)</span>

<p>输入：无平方因子<img src="./latex/latex2png-PolyFacZ_75658260_0.gif" alt="$ n $" class="latex-inline" style="vertical-align: 0px" width="10" height="8">次本原多项式<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">，其中<img src="./latex/latex2png-PolyFacZ_68944530_-5.gif" alt="$\mathrm{lc}(f)>0$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">且<img src="./latex/latex2png-PolyFacZ_231597701_-5.gif" alt="$\|f\|_{\infty}=A$" class="latex-inline" style="vertical-align: -5px" width="74" height="18">,</p>

<p>输出：<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">在<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上的不可约因子<img src="./latex/latex2png-PolyFacZ_188400728_-5.gif" alt="$\{f_1,\ldots,f_k\}$" class="latex-inline" style="vertical-align: -5px" width="83" height="18">.</p>

<ol>
<li>若<img src="./latex/latex2png-PolyFacZ_167998484_0.gif" alt="$n=1$" class="latex-inline" style="vertical-align: 0px" width="39" height="11">则输出<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,否则<img src="./latex/latex2png-PolyFacZ_112785990_-5.gif" alt="$b=\mathrm{lc}(f),B=(n+1)^{1/2}2^nAb$" class="latex-inline" style="vertical-align: -5px" width="216" height="20">,</li>

<li>随机任取一个奇素数<img src="./latex/latex2png-PolyFacZ_105971577_-5.gif" alt="$p\in(2B,4B)$" class="latex-inline" style="vertical-align: -5px" width="92" height="18">,直至<img src="./latex/latex2png-PolyFacZ_16859241_-5.gif" alt="$\gcd(\overline{f},\overline{f}')=1\in\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="155" height="23">,即满足上面推论条件,</li>

<li>利用有限域上因子分解算法求出<img src="./latex/latex2png-PolyFacZ_95129026_-5.gif" alt="$g_1,\ldots,g_r\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="116" height="18">,其无穷范数均比<img src="./latex/latex2png-PolyFacZ_186938388_-5.gif" alt="$p/2$" class="latex-inline" style="vertical-align: -5px" width="25" height="18">要小，且在<img src="./latex/latex2png-PolyFacZ_92825302_-5.gif" alt="$\field{p}$" class="latex-inline" style="vertical-align: -5px" width="17" height="17">上不可约，于是<img src="./latex/latex2png-PolyFacZ_36485343_-5.gif" alt="$f\equiv bg_1\cdots g_r\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="158" height="18">,</li>

<li><img src="./latex/latex2png-PolyFacZ_230096074_-5.gif" alt="$T=\{1,\ldots,r\}$" class="latex-inline" style="vertical-align: -5px" width="103" height="18">,<img src="./latex/latex2png-PolyFacZ_251884564_0.gif" alt="$s=1$" class="latex-inline" style="vertical-align: 0px" width="36" height="11">,<img src="./latex/latex2png-PolyFacZ_172920293_-2.gif" alt="$G=\emptyset$" class="latex-inline" style="vertical-align: -2px" width="42" height="15">,<img src="./latex/latex2png-PolyFacZ_235959958_-4.gif" alt="$f^*=f$" class="latex-inline" style="vertical-align: -4px" width="48" height="16">,</li>

<li>当<img src="./latex/latex2png-PolyFacZ_246277402_-4.gif" alt="$2s\le\#T$" class="latex-inline" style="vertical-align: -4px" width="64" height="16">时循环执行下面4步，否则转第10步,</li>

<li>枚举<img src="./latex/latex2png-PolyFacZ_43414546_0.gif" alt="$T$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">的所有<img src="./latex/latex2png-PolyFacZ_42824722_0.gif" alt="$s$" class="latex-inline" style="vertical-align: 0px" width="6" height="8">元子集<img src="./latex/latex2png-PolyFacZ_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13">,并做下两步7、8循环：</li>

<li>计算<img src="./latex/latex2png-PolyFacZ_84702228_-4.gif" alt="$g^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">,<img src="./latex/latex2png-PolyFacZ_74668388_-5.gif" alt="$h^*\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">使得其无穷范数比<img src="./latex/latex2png-PolyFacZ_186938388_-5.gif" alt="$p/2$" class="latex-inline" style="vertical-align: -5px" width="25" height="18">要小并且<img src="./latex/latex2png-PolyFacZ_159368694_-7.gif" alt="$g^*\equiv b\prod_{i\in S}g_i\pmod{p}$" class="latex-inline" style="vertical-align: -7px" width="168" height="20">,<img src="./latex/latex2png-PolyFacZ_180242878_-8.gif" alt="$h^*\equiv b\prod_{i\in T\setminus S}g_i\pmod{p}$" class="latex-inline" style="vertical-align: -8px" width="185" height="21">,</li>

<li>若<img src="./latex/latex2png-PolyFacZ_261955809_-5.gif" alt="$\|g^*\|_1\|h^*\|_1\le B$" class="latex-inline" style="vertical-align: -5px" width="116" height="18">则<img src="./latex/latex2png-PolyFacZ_28858641_-5.gif" alt="$T=T\setminus S$" class="latex-inline" style="vertical-align: -5px" width="73" height="18">,<img src="./latex/latex2png-PolyFacZ_2938495_-5.gif" alt="$G=G\bigcup\{\mathrm{pp}(g^*)\}$" class="latex-inline" style="vertical-align: -5px" width="126" height="18">,<img src="./latex/latex2png-PolyFacZ_262780266_-5.gif" alt="$f^*=\mathrm{pp}(h^*)$" class="latex-inline" style="vertical-align: -5px" width="86" height="18">,<img src="./latex/latex2png-PolyFacZ_145359506_-5.gif" alt="$b=\mathrm{lc}(f^*)$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">,跳出6、7、8循环并转第5步,</li>

<li><img src="./latex/latex2png-PolyFacZ_35424607_-2.gif" alt="$s=s+1$" class="latex-inline" style="vertical-align: -2px" width="64" height="13">,</li>

<li>输出<img src="./latex/latex2png-PolyFacZ_52159108_-5.gif" alt="$G\bigcup\{f^*\}$" class="latex-inline" style="vertical-align: -5px" width="62" height="18">.</li>
</ol>


</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法有效性)</span>
由第2步<img src="./latex/latex2png-PolyFacZ_240967715_-5.gif" alt="$p>B\Rightarrow p\not|b$" class="latex-inline" style="vertical-align: -5px" width="100" height="18">我们已经知道<img src="./latex/latex2png-PolyFacZ_212247402_-4.gif" alt="$\overline{f}$" class="latex-inline" style="vertical-align: -4px" width="10" height="19">是无平方因子的。在第8步中，若条件真则有<img src="./latex/latex2png-PolyFacZ_152753397_-4.gif" alt="$g^*h^*=bf^*$" class="latex-inline" style="vertical-align: -4px" width="79" height="16">，因为由<img src="./latex/latex2png-PolyFacZ_24468207_-5.gif" alt="$g^*h^*\equiv bf^*\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="144" height="18">和<img src="./latex/latex2png-PolyFacZ_88221100_-5.gif" alt="$\|g^*h^*\|_{\infty}\le\|g^*h^*\|_1\le\|g^*\|_1\|h^*\|_1\le B<p/2$" class="latex-inline" style="vertical-align: -5px" width="328" height="18">知等式是成立的。记<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的因子<img src="./latex/latex2png-PolyFacZ_16144738_-5.gif" alt="$u\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="58" height="18">,其在<img src="./latex/latex2png-PolyFacZ_71410771_-5.gif" alt="$\mathbb{Z}_p[x]$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">中不可约因子个数<img src="./latex/latex2png-PolyFacZ_50618853_-5.gif" alt="$\mu(u)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">.现在我们要归纳证明在每次到第5步时，有下面命题成立：

<ol>
<li><img src="./latex/latex2png-PolyFacZ_41704750_-8.gif" alt="$f^*\equiv b\prod_{i\in T}g_i\pmod{p},\quad b=\mathrm{lc}(f^*),\quad f=f^*\prod_{g\in G}g$" class="latex-inline" style="vertical-align: -8px" width="396" height="21">,</li>

<li><img src="./latex/latex2png-PolyFacZ_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">中多项式均不可约,</li>

<li><img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">本原且它的任何一个不可约因子<img src="./latex/latex2png-PolyFacZ_16213090_-5.gif" alt="$u\in\mathrm{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">有<img src="./latex/latex2png-PolyFacZ_267207684_-5.gif" alt="$\mu(u)\ge s$" class="latex-inline" style="vertical-align: -5px" width="62" height="18">.</li>
</ol>

<p>初始时命题显然成立，假设命题在每次循环进行到第7步前均是成立的，此时经过第7步后当第8步的条件成立时，各量均要发生变化，根据前面的分析则有<img src="./latex/latex2png-PolyFacZ_152753397_-4.gif" alt="$g^*h^*=bf^*$" class="latex-inline" style="vertical-align: -4px" width="79" height="16">,于是<img src="./latex/latex2png-PolyFacZ_6469010_-5.gif" alt="$\mathrm{pp}(g^*)$" class="latex-inline" style="vertical-align: -5px" width="46" height="18">是<img src="./latex/latex2png-PolyFacZ_103833092_-5.gif" alt="$\mathrm{pp}(bf^*)=f^*$" class="latex-inline" style="vertical-align: -5px" width="94" height="18">的因子。由于<img src="./latex/latex2png-PolyFacZ_148410270_-5.gif" alt="$\mu(g^*)=s$" class="latex-inline" style="vertical-align: -5px" width="68" height="18">且对任何<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">的不可约因子<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">有<img src="./latex/latex2png-PolyFacZ_267207684_-5.gif" alt="$\mu(u)\ge s$" class="latex-inline" style="vertical-align: -5px" width="62" height="18">,则<img src="./latex/latex2png-PolyFacZ_6469010_-5.gif" alt="$\mathrm{pp}(g^*)$" class="latex-inline" style="vertical-align: -5px" width="46" height="18">是<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">的不可约因子.当<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">有一个不可约因子<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">满足<img src="./latex/latex2png-PolyFacZ_45646322_-5.gif" alt="$\mu(g)=s$" class="latex-inline" style="vertical-align: -5px" width="61" height="18">时，当循环到s时必然能将此因子选出，这一点可以构造来证明，即取指标集<img src="./latex/latex2png-PolyFacZ_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13">为<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">在<img src="./latex/latex2png-PolyFacZ_223283783_-5.gif" alt="$\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="35" height="18">中不可约因子的编号.</p>

<p>最后一步是证明在第5步时，若<img src="./latex/latex2png-PolyFacZ_24732799_-4.gif" alt="$2s>\#T$" class="latex-inline" style="vertical-align: -4px" width="64" height="16">，则<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">是不可约的.令<img src="./latex/latex2png-PolyFacZ_15227234_-5.gif" alt="$g\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">是<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">的一个不可约因子且<img src="./latex/latex2png-PolyFacZ_221509670_-5.gif" alt="$h=f^*/g$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">非平凡,于是<img src="./latex/latex2png-PolyFacZ_153417188_-5.gif" alt="$s\le\mu(g),\mu(h)\le\#T$" class="latex-inline" style="vertical-align: -5px" width="148" height="18">.但是<img src="./latex/latex2png-PolyFacZ_231665664_-5.gif" alt="$\mu(g)+\mu(h)=\#T$" class="latex-inline" style="vertical-align: -5px" width="132" height="18">，且<img src="./latex/latex2png-PolyFacZ_119997264_-5.gif" alt="$s>\#T/2$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">，则<img src="./latex/latex2png-PolyFacZ_42103826_0.gif" alt="$h$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">必为常数，<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">必不可约.
<span class="proof-end">□</span></p>

</div>

<div class="problem">
<span class="proof-header">例1<a name="example:factorization1"></a></span><span class="theorem-name"></span>
考虑<img src="./latex/latex2png-PolyFacZ_59364051_-4.gif" alt="$f=4x^4+13x^3+28x^2+27x+18$" class="latex-inline" style="vertical-align: -4px" width="247" height="18">在<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">上的分解.
<span class="example-end">◇</span>

</div>

<div class="solution">
<span class="proof-header">解</span>
<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">是本原的,且<img src="./latex/latex2png-PolyFacZ_218506876_-4.gif" alt="$f'=16x^3+39x^2+56x+27$" class="latex-inline" style="vertical-align: -4px" width="206" height="18">,<img src="./latex/latex2png-PolyFacZ_9996155_-5.gif" alt="$\mathrm{disc}(f)=1656288$" class="latex-inline" style="vertical-align: -5px" width="130" height="18">,于是<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">无平方因子.此时<img src="./latex/latex2png-PolyFacZ_168195092_0.gif" alt="$n=4$" class="latex-inline" style="vertical-align: 0px" width="40" height="11">,<img src="./latex/latex2png-PolyFacZ_262507462_-1.gif" alt="$A=28$" class="latex-inline" style="vertical-align: -1px" width="51" height="13">,<img src="./latex/latex2png-PolyFacZ_59833710_-5.gif" alt="$b=\mathrm{lc}(f)=4$" class="latex-inline" style="vertical-align: -5px" width="94" height="18">,则<img src="./latex/latex2png-PolyFacZ_158002244_-5.gif" alt="$B=(n+1)^{1/2}2^nAb=1792\sqrt{5}=4007.03$" class="latex-inline" style="vertical-align: -5px" width="298" height="20">,取素数<img src="./latex/latex2png-PolyFacZ_202342586_-4.gif" alt="$p=8017>2B$" class="latex-inline" style="vertical-align: -4px" width="108" height="16">且<img src="./latex/latex2png-PolyFacZ_154358845_-5.gif" alt="$p\not|\mathrm{disc}(f)$" class="latex-inline" style="vertical-align: -5px" width="72" height="18">,此时可以得到<img src="./latex/latex2png-PolyFacZ_151538047_-3.gif" alt="$\mathbb{Z}_{8017}$" class="latex-inline" style="vertical-align: -3px" width="38" height="15">上的分解：<img src="./latex/latex2png-PolyFacZ_186372327_.gif" alt="$$f\equiv 4(x-955)(x+957)(x^2-2003x-4007)\pmod{p}.$$" class="latex-display" width="580" height="20">

<p>首先<img src="./latex/latex2png-PolyFacZ_251884564_0.gif" alt="$s=1$" class="latex-inline" style="vertical-align: 0px" width="36" height="11">,若取<img src="./latex/latex2png-PolyFacZ_119147331_-5.gif" alt="$S=\{1\}$" class="latex-inline" style="vertical-align: -5px" width="55" height="18">,则
<img src="./latex/latex2png-PolyFacZ_262193770_.gif" alt="$$g^*=4(x-955)=4x-3820,$$" class="latex-display" width="580" height="18">
<img src="./latex/latex2png-PolyFacZ_92019320_.gif" alt="$$h^*=4(x+957)(x^2-2003x-4007)=4x^3+3833x^2-3226x-2275,$$" class="latex-display" width="580" height="20">
<img src="./latex/latex2png-PolyFacZ_211961299_.gif" alt="$$\|g^*\|_1\|h^*\|_1=(4+3820)(4+2833+3226+2275)>B,$$" class="latex-display" width="580" height="18">
同样的取<img src="./latex/latex2png-PolyFacZ_135924547_-5.gif" alt="$S=\{2\}$" class="latex-inline" style="vertical-align: -5px" width="55" height="18">时也可验证是不可以的。若取<img src="./latex/latex2png-PolyFacZ_152701763_-5.gif" alt="$S=\{3\}$" class="latex-inline" style="vertical-align: -5px" width="55" height="18">,则
<img src="./latex/latex2png-PolyFacZ_236385908_.gif" alt="$$g^*=4(x^2-2003x-4007)=4x^2+5x+6,$$" class="latex-display" width="580" height="20">
<img src="./latex/latex2png-PolyFacZ_41872275_.gif" alt="$$h^*=4(x-955)(x+957)=4x^2+8x+12,$$" class="latex-display" width="580" height="20">
此时<img src="./latex/latex2png-PolyFacZ_261337799_-5.gif" alt="$\|g^*\|_1\|h^*\|_1=15*24=360<B$" class="latex-inline" style="vertical-align: -5px" width="234" height="18">,则<img src="./latex/latex2png-PolyFacZ_176468506_-5.gif" alt="$G=\{4x^2+5x+6\}$" class="latex-inline" style="vertical-align: -5px" width="141" height="19">,<img src="./latex/latex2png-PolyFacZ_127582801_-5.gif" alt="$f^*=\mathrm{pp}(h^*)=x^2+2x+3$" class="latex-inline" style="vertical-align: -5px" width="193" height="19">,<img src="./latex/latex2png-PolyFacZ_141766455_-5.gif" alt="$b=\mathrm{lc}(f^*)=1$" class="latex-inline" style="vertical-align: -5px" width="101" height="18">,<img src="./latex/latex2png-PolyFacZ_89152139_-5.gif" alt="$T=\{1,2\}$" class="latex-inline" style="vertical-align: -5px" width="73" height="18">,下一步<img src="./latex/latex2png-PolyFacZ_251950100_0.gif" alt="$s=2$" class="latex-inline" style="vertical-align: 0px" width="37" height="11">,循环条件不满足，则<img src="./latex/latex2png-PolyFacZ_220305562_-5.gif" alt="$G=G\bigcup\{f^*\}=\{x^2+2x+3,4x^2+5x+6\}$" class="latex-inline" style="vertical-align: -5px" width="318" height="19">.</p>


</div>

<p>对于一般的多项式,我们可以如下分解.当然,在算法第4步分解无平方因子多项式时,也可以调用后面几节将要介绍的分解算法.</p>

<div class="algorithm">
<span class="theorem-header">算法2<a name=""></a></span><span class="theorem-name">(整系数多项式的因子分解2)</span>

<p>输入：<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">，<img src="./latex/latex2png-PolyFacZ_68388180_-4.gif" alt="$\deg f=n>1$" class="latex-inline" style="vertical-align: -4px" width="99" height="16">且<img src="./latex/latex2png-PolyFacZ_231597701_-5.gif" alt="$\|f\|_{\infty}=A$" class="latex-inline" style="vertical-align: -5px" width="74" height="18">,</p>

<p>输出：常数<img src="./latex/latex2png-PolyFacZ_184517536_-1.gif" alt="$c\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -1px" width="38" height="13">和序对集<img src="./latex/latex2png-PolyFacZ_242807412_-5.gif" alt="$\{(f_1,e_1),\ldots,(f_k,e_k)\}$" class="latex-inline" style="vertical-align: -5px" width="154" height="18">,其中<img src="./latex/latex2png-PolyFacZ_43669860_-5.gif" alt="$f_i\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="61" height="18">均是不可约两两互素的多项式,<img src="./latex/latex2png-PolyFacZ_194476096_-2.gif" alt="$e_i\in\mathbb{N}$" class="latex-inline" style="vertical-align: -2px" width="46" height="14">,且<img src="./latex/latex2png-PolyFacZ_226378006_-5.gif" alt="$f=c\prod_{i=1}^{k}f_i^{e_i}$" class="latex-inline" style="vertical-align: -5px" width="101" height="21">.</p>

<ol>
<li><img src="./latex/latex2png-PolyFacZ_224036701_-5.gif" alt="$c=\mathrm{cont}(f)$" class="latex-inline" style="vertical-align: -5px" width="82" height="18">,<img src="./latex/latex2png-PolyFacZ_58568984_-5.gif" alt="$g=\mathrm{pp}(f)$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">,若<img src="./latex/latex2png-PolyFacZ_71041682_-5.gif" alt="$\mathrm{lc}(f)<0$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">则<img src="./latex/latex2png-PolyFacZ_267553735_0.gif" alt="$c=-c$" class="latex-inline" style="vertical-align: 0px" width="49" height="8">,<img src="./latex/latex2png-PolyFacZ_267291590_-4.gif" alt="$g=-g$" class="latex-inline" style="vertical-align: -4px" width="52" height="12">,</li>

<li>调用算法<a class="ref-th-external" href="PolyFacZp.html#al:SFD">9</a>得到分解<img src="./latex/latex2png-PolyFacZ_197338746_-9.gif" alt="$g=\prod_{1\le i\le s}g_i^i$" class="latex-inline" style="vertical-align: -9px" width="102" height="23">,且<img src="./latex/latex2png-PolyFacZ_245092532_-5.gif" alt="$\mathrm{lc}(g_i)>0$" class="latex-inline" style="vertical-align: -5px" width="68" height="18">,<img src="./latex/latex2png-PolyFacZ_87913492_-4.gif" alt="$g_s$" class="latex-inline" style="vertical-align: -4px" width="14" height="12">非平凡,</li>

<li><img src="./latex/latex2png-PolyFacZ_172920293_-2.gif" alt="$G=\emptyset$" class="latex-inline" style="vertical-align: -2px" width="42" height="15">,</li>

<li>对<img src="./latex/latex2png-PolyFacZ_162174844_-3.gif" alt="$1\le i\le s$" class="latex-inline" style="vertical-align: -3px" width="64" height="15">循环,调用上面算法<a class="ref-th" href="#al:bpfc1">1</a>得到<img src="./latex/latex2png-PolyFacZ_87258132_-4.gif" alt="$g_i$" class="latex-inline" style="vertical-align: -4px" width="13" height="12">的所有不可约因子<img src="./latex/latex2png-PolyFacZ_112037330_-5.gif" alt="$h_1,\ldots,h_t\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="118" height="18">,<img src="./latex/latex2png-PolyFacZ_11242379_-5.gif" alt="$G=G\bigcup\{(h_1,i),\ldots,(h_t,i)\}$" class="latex-inline" style="vertical-align: -5px" width="200" height="18">,</li>

<li>输出<img src="./latex/latex2png-PolyFacZ_41776146_0.gif" alt="$c$" class="latex-inline" style="vertical-align: 0px" width="7" height="8">和<img src="./latex/latex2png-PolyFacZ_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">.</li>
</ol>


</div>


<h2><a name="sec2" id="sec2"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>Hensel提升(lifting)理论</h2>

<p class="first">以下我们全在整数环这个特殊的UFD中讨论,有些算法和命题在将<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">换为其它的UFD,如<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">也是正确的。</p>

<p>当我们已知一个分解<img src="./latex/latex2png-PolyFacZ_72195779_-5.gif" alt="$f\equiv gh\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="113" height="18">(<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">,<img src="./latex/latex2png-PolyFacZ_42103826_0.gif" alt="$h$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">互素)时，最简单的问题是获得分解<img src="./latex/latex2png-PolyFacZ_129015854_-5.gif" alt="$f\equiv g^*h^*\pmod{p^2}$" class="latex-inline" style="vertical-align: -5px" width="136" height="19">,即将其“提升”。由于<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">是素数，则存在<img src="./latex/latex2png-PolyFacZ_42824722_0.gif" alt="$s$" class="latex-inline" style="vertical-align: 0px" width="6" height="8">,<img src="./latex/latex2png-PolyFacZ_16079202_-5.gif" alt="$t\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="54" height="18">使得<img src="./latex/latex2png-PolyFacZ_132872931_-5.gif" alt="$sg+th\equiv 1\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="146" height="18">,如果我们取：<img src="./latex/latex2png-PolyFacZ_205260206_.gif" alt="$$e=f-gh,\quad g^*=g+te,\quad h^*=h+se,$$" class="latex-display" width="580" height="17">则有
<img src="./latex/latex2png-PolyFacZ_14426323_.gif" alt="
\begin{align*}
f-g^*h^*&=f-(g+te)(h+se)=f-gh-(sg+th)e-ste^2\notag \\
&=(1-sg-th)e-ste^2\equiv 0\pmod{p^2},\notag
\end{align*}
" class="latex-display" width="580" height="51">
这样可以达到我们的要求。</p>

<div class="lemma">
<span class="theorem-header">引理2<a name=""></a></span><span class="theorem-name"></span>
在<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">中,我们有如下结论:

<ol>
<li>设<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,<img src="./latex/latex2png-PolyFacZ_15227234_-5.gif" alt="$g\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">,其中<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">非零且首一,则存在唯一的多项式<img src="./latex/latex2png-PolyFacZ_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">,<img src="./latex/latex2png-PolyFacZ_15948130_-5.gif" alt="$r\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="56" height="18">使得<img src="./latex/latex2png-PolyFacZ_235103181_-4.gif" alt="$f=qg+r$" class="latex-inline" style="vertical-align: -4px" width="75" height="16">且<img src="./latex/latex2png-PolyFacZ_229222222_-4.gif" alt="$\deg r<\deg g$" class="latex-inline" style="vertical-align: -4px" width="94" height="16">.</li>

<li><img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">,<img src="./latex/latex2png-PolyFacZ_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">,<img src="./latex/latex2png-PolyFacZ_42759186_0.gif" alt="$r$" class="latex-inline" style="vertical-align: 0px" width="7" height="8">同上，若对于某个整数<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">有<img src="./latex/latex2png-PolyFacZ_94272882_-5.gif" alt="$f\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="111" height="18">,则<img src="./latex/latex2png-PolyFacZ_88308625_-5.gif" alt="$q\equiv r\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="140" height="18">.</li>
</ol>


</div>

<div class="proof">
<span class="proof-header">证明</span>
第一条基本同Euclid环中的证明方法,只要注意到<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">是首一的即可。对于第二条，由<img src="./latex/latex2png-PolyFacZ_94272882_-5.gif" alt="$f\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="111" height="18">知必有<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">中的多项式<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">使得<img src="./latex/latex2png-PolyFacZ_200500173_-4.gif" alt="$f=mf^*$" class="latex-inline" style="vertical-align: -4px" width="62" height="16">，于是必存在唯一的<img src="./latex/latex2png-PolyFacZ_267451617_-4.gif" alt="$q^*,r^*$" class="latex-inline" style="vertical-align: -4px" width="37" height="16">使得<img src="./latex/latex2png-PolyFacZ_33831567_.gif" alt="$$f^*=q^*g+r^*,\quad \deg r^*<\deg q^*,$$" class="latex-display" width="580" height="17">此时有<img src="./latex/latex2png-PolyFacZ_182023208_-5.gif" alt="$f=mf^*=(mq^*)g+(mr^*)$" class="latex-inline" style="vertical-align: -5px" width="199" height="18">,由唯一性得<img src="./latex/latex2png-PolyFacZ_15950621_-4.gif" alt="$q=mq^*$" class="latex-inline" style="vertical-align: -4px" width="59" height="16">,<img src="./latex/latex2png-PolyFacZ_826611_0.gif" alt="$r=mr^*$" class="latex-inline" style="vertical-align: 0px" width="59" height="12">.
<span class="proof-end">□</span>

</div>

<p>我们可以给出如下的单步Hensel提升(Hensel Step)算法.</p>

<div class="algorithm">
<span class="theorem-header">算法3<a name="al:henselstep"></a></span><span class="theorem-name">(单步Hensel提升)</span>

<p>输入：整数<img src="./latex/latex2png-PolyFacZ_184517376_-1.gif" alt="$m\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -1px" width="46" height="13">,多项式<img src="./latex/latex2png-PolyFacZ_251026277_-5.gif" alt="$f,g,h,s,t\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="118" height="18">使得<img src="./latex/latex2png-PolyFacZ_112763403_.gif" alt="$$f\equiv gh\pmod{m},\quad sg+th\equiv 1\pmod{m},$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_42103826_0.gif" alt="$h$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">首一，且<img src="./latex/latex2png-PolyFacZ_60348738_-4.gif" alt="$\deg f=n=\deg g+\deg h$" class="latex-inline" style="vertical-align: -4px" width="186" height="16">,<img src="./latex/latex2png-PolyFacZ_229152590_-4.gif" alt="$\deg s<\deg h$" class="latex-inline" style="vertical-align: -4px" width="95" height="16">,<img src="./latex/latex2png-PolyFacZ_229214030_-4.gif" alt="$\deg t<\deg g$" class="latex-inline" style="vertical-align: -4px" width="92" height="16">.</p>

<p>输出：多项式<img src="./latex/latex2png-PolyFacZ_159191172_-5.gif" alt="$g^*,h^*,s^*,t^*\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="133" height="18">使得<img src="./latex/latex2png-PolyFacZ_20566697_.gif" alt="$$f\equiv g^*h^*\pmod{m^2},\quad s^*g^*+t^*h^*\equiv 1\pmod{m^2},$$" class="latex-display" width="580" height="20"> <img src="./latex/latex2png-PolyFacZ_101479444_0.gif" alt="$h^*$" class="latex-inline" style="vertical-align: 0px" width="16" height="12">首一，<img src="./latex/latex2png-PolyFacZ_50560368_-5.gif" alt="$g^*\equiv g\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="118" height="18">,<img src="./latex/latex2png-PolyFacZ_33717616_-5.gif" alt="$h^*\equiv h\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="120" height="18">,<img src="./latex/latex2png-PolyFacZ_151552657_-5.gif" alt="$s^*\equiv s\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="116" height="18">,<img src="./latex/latex2png-PolyFacZ_168395409_-5.gif" alt="$t^*\equiv t\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="113" height="18">,<img src="./latex/latex2png-PolyFacZ_93648659_-4.gif" alt="$\deg g^*=\deg g$" class="latex-inline" style="vertical-align: -4px" width="102" height="16">,<img src="./latex/latex2png-PolyFacZ_94762771_-4.gif" alt="$\deg h^*=\deg h$" class="latex-inline" style="vertical-align: -4px" width="104" height="16">,<img src="./latex/latex2png-PolyFacZ_108104392_-4.gif" alt="$\deg s^*<\deg h^*$" class="latex-inline" style="vertical-align: -4px" width="109" height="16">,<img src="./latex/latex2png-PolyFacZ_143553848_-4.gif" alt="$\deg t^*<\deg g^*$" class="latex-inline" style="vertical-align: -4px" width="106" height="16">.</p>

<ol>
<li>计算<img src="./latex/latex2png-PolyFacZ_260022033_-5.gif" alt="$e,q,r,g^*,h^*\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="134" height="18">使得<img src="./latex/latex2png-PolyFacZ_229156686_-4.gif" alt="$\deg r<\deg h$" class="latex-inline" style="vertical-align: -4px" width="95" height="16">且
<img src="./latex/latex2png-PolyFacZ_126614503_.gif" alt="
\begin{align*}
e&\equiv f-gh\pmod{m^2},\qquad &se&\equiv qh+r\pmod{m^2},\notag\\
g^*&\equiv g+te+qg\pmod{m^2}, &h^* &\equiv h+r\pmod{m^2}, \notag
\end{align*}
" class="latex-display" width="580" height="51"></li>
<li>计算<img src="./latex/latex2png-PolyFacZ_242380012_-5.gif" alt="$b,c,d,s^*,t^*\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="130" height="18">使得<img src="./latex/latex2png-PolyFacZ_99544028_-4.gif" alt="$\deg d<\deg h^*$" class="latex-inline" style="vertical-align: -4px" width="103" height="16">且
<img src="./latex/latex2png-PolyFacZ_57137335_.gif" alt="
\begin{align*}
b&\equiv sg^*+th^*-1\pmod{m^2},\qquad &sb&\equiv ch^*+d\pmod{m^2},\notag\\
s^*&\equiv s-d\pmod{m^2},&t^*&\equiv t-tb-cg^*\pmod{m^2},\notag
\end{align*}
" class="latex-display" width="580" height="51"></li>
<li>输出<img src="./latex/latex2png-PolyFacZ_132380116_-4.gif" alt="$g^*,h^*,s^*,t^*$" class="latex-inline" style="vertical-align: -4px" width="83" height="16">.</li>
</ol>



</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法有效性)</span>
我们逐项验证各项输出的要求.首先，<img src="./latex/latex2png-PolyFacZ_139419603_-5.gif" alt="$f\equiv g^*h^*\pmod{m^2}$" class="latex-inline" style="vertical-align: -5px" width="143" height="19">,
<img src="./latex/latex2png-PolyFacZ_204296921_.gif" alt="
\begin{align*}
f-g^*h^*&\equiv f-(g+te+qg)(h+r)\equiv f-(g+te+qg)(h+se-qh)\notag\\
&\equiv (f-gh)-(sg+th)e-ste^2+q^2gh+(th-sg)eq\notag\\
&\equiv (1-sg-th)e-ste^2+q^2gh+(th-sg)eq\equiv 0\pmod{m^2},\notag
\end{align*}
" class="latex-display" width="580" height="80">
这是因为根据前面的引理我们由<img src="./latex/latex2png-PolyFacZ_13664910_-5.gif" alt="$se\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="116" height="18">得到<img src="./latex/latex2png-PolyFacZ_88308625_-5.gif" alt="$q\equiv r\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="140" height="18">.

<p>由<img src="./latex/latex2png-PolyFacZ_229156686_-4.gif" alt="$\deg r<\deg h$" class="latex-inline" style="vertical-align: -4px" width="95" height="16">知<img src="./latex/latex2png-PolyFacZ_101479444_0.gif" alt="$h^*$" class="latex-inline" style="vertical-align: 0px" width="16" height="12">也是首一的,且<img src="./latex/latex2png-PolyFacZ_110996046_.gif" alt="$$g^*-g\equiv te+qg\equiv 0\pmod{m},$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_69031927_.gif" alt="$$h^*-h\equiv r\equiv 0\pmod{m},$$" class="latex-display" width="580" height="18"> 由<img src="./latex/latex2png-PolyFacZ_211290756_-5.gif" alt="$h^*\equiv h+r\pmod{m^2}$" class="latex-inline" style="vertical-align: -5px" width="155" height="19">也可得到<img src="./latex/latex2png-PolyFacZ_94762771_-4.gif" alt="$\deg h^*=\deg h$" class="latex-inline" style="vertical-align: -4px" width="104" height="16">,于是<img src="./latex/latex2png-PolyFacZ_190779944_-4.gif" alt="$\deg g^*=\deg f-\deg h^*=\deg f-\deg h=\deg g$" class="latex-inline" style="vertical-align: -4px" width="345" height="16">.</p>

<p>其次,<img src="./latex/latex2png-PolyFacZ_205477184_-5.gif" alt="$s^*g^*+t^*h^*\equiv 1\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="183" height="18">,
<img src="./latex/latex2png-PolyFacZ_31284937_.gif" alt="
\begin{align*}
s^*g^*+t^*h^*&\equiv (s-d)g^*+(t-tb-cg^*)h^*\notag\\
&\equiv (s-sb+ch^*)g^*+(t-tb-cg^*)h^*\equiv (sg^*+th^*)(1-b)\notag\\
&\equiv (sg^*+th^*)(2-sg^*-th^*)\equiv 1-(sg^*+th^*-1)^2\equiv 1-(sg+th-1)^2\notag\\
&\equiv 1\pmod{m^2},\notag
\end{align*}
" class="latex-display" width="580" height="110">
由<img src="./latex/latex2png-PolyFacZ_13468302_-5.gif" alt="$sb\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="116" height="18">可知<img src="./latex/latex2png-PolyFacZ_90143633_-5.gif" alt="$c\equiv d\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="140" height="18">,于是<img src="./latex/latex2png-PolyFacZ_18703095_.gif" alt="$$s^*-s\equiv d\equiv 0\pmod{m},$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_77142030_.gif" alt="$$t^*-t\equiv tb+cg^*\equiv 0\pmod{m},$$" class="latex-display" width="580" height="18"> 而<img src="./latex/latex2png-PolyFacZ_99544028_-4.gif" alt="$\deg d<\deg h^*$" class="latex-inline" style="vertical-align: -4px" width="103" height="16">,于是<img src="./latex/latex2png-PolyFacZ_118253167_-5.gif" alt="$\deg s^*\le\deg(s-d)<\deg h^*$" class="latex-inline" style="vertical-align: -5px" width="206" height="18">,由<img src="./latex/latex2png-PolyFacZ_156803710_-5.gif" alt="$s^*g^*+t^*h^*\equiv 1\pmod{m^2}$" class="latex-inline" style="vertical-align: -5px" width="190" height="19">知<img src="./latex/latex2png-PolyFacZ_143553848_-4.gif" alt="$\deg t^*<\deg g^*$" class="latex-inline" style="vertical-align: -4px" width="106" height="16">.所有结论证毕.
<span class="proof-end">□</span></p>

</div>

<p>既然本节开始提出的方法已经能够解决问题,为什么还要引入上面的算法呢？我们通过下面一个例子来说明问题：</p>

<div class="problem">
<span class="proof-header">例2<a name=""></a></span><span class="theorem-name"></span>
考虑<img src="./latex/latex2png-PolyFacZ_150604232_-4.gif" alt="$f=x^4-1$" class="latex-inline" style="vertical-align: -4px" width="75" height="18">,<img src="./latex/latex2png-PolyFacZ_151483412_-1.gif" alt="$m=5$" class="latex-inline" style="vertical-align: -1px" width="45" height="12">,<img src="./latex/latex2png-PolyFacZ_50624150_0.gif" alt="$h=x-2$" class="latex-inline" style="vertical-align: 0px" width="69" height="12">,<img src="./latex/latex2png-PolyFacZ_73601625_-4.gif" alt="$g=x^3+2x^2-x-2$" class="latex-inline" style="vertical-align: -4px" width="151" height="18">,<img src="./latex/latex2png-PolyFacZ_268143558_0.gif" alt="$s=-2$" class="latex-inline" style="vertical-align: 0px" width="50" height="11">,<img src="./latex/latex2png-PolyFacZ_51041637_0.gif" alt="$t=2x^2-2x-1$" class="latex-inline" style="vertical-align: 0px" width="119" height="14">的情况.
<span class="example-end">◇</span>

</div>

<div class="solution">
<span class="proof-header">解</span>
由本节开始的方法处理,有<img src="./latex/latex2png-PolyFacZ_78800072_.gif" alt="$$e=f-gh=5x^2-5,$$" class="latex-display" width="580" height="19"> <img src="./latex/latex2png-PolyFacZ_129989004_.gif" alt="$$g^*=g+te=10x^4-9x^3-13x^2+9x+3,$$" class="latex-display" width="580" height="19"> <img src="./latex/latex2png-PolyFacZ_43012438_.gif" alt="$$h^*=h+se=-10x^2+x+8.$$" class="latex-display" width="580" height="17">
我们看到,<img src="./latex/latex2png-PolyFacZ_93648915_-4.gif" alt="$\deg g^*>\deg g$" class="latex-inline" style="vertical-align: -4px" width="102" height="16">,<img src="./latex/latex2png-PolyFacZ_94763027_-4.gif" alt="$\deg h^*>\deg h$" class="latex-inline" style="vertical-align: -4px" width="104" height="16">,这种规模的增大无疑对后续的提升造成更多的计算负担,并且次数的提高也不是我们想要的正确的因子分解的结果.因此我们用算法<a class="ref-th" href="#al:henselstep">3</a>来进行提升:

<p><img src="./latex/latex2png-PolyFacZ_66221076_0.gif" alt="$ e $" class="latex-inline" style="vertical-align: 0px" width="7" height="8">任取为<img src="./latex/latex2png-PolyFacZ_184050760_-1.gif" alt="$5x^2-5$" class="latex-inline" style="vertical-align: -1px" width="54" height="15">,则对<img src="./latex/latex2png-PolyFacZ_149910546_0.gif" alt="$se$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">进行<img src="./latex/latex2png-PolyFacZ_42103826_0.gif" alt="$h$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">的带余除法有：<img src="./latex/latex2png-PolyFacZ_62842057_.gif" alt="$$se=-10x^2+1\equiv (-10x+5)h-5\pmod{25},$$" class="latex-display" width="580" height="20"> 于是<img src="./latex/latex2png-PolyFacZ_217037802_-4.gif" alt="$q=-10x+5$" class="latex-inline" style="vertical-align: -4px" width="97" height="15">,<img src="./latex/latex2png-PolyFacZ_488506_-1.gif" alt="$r=-5$" class="latex-inline" style="vertical-align: -1px" width="51" height="12">,故<img src="./latex/latex2png-PolyFacZ_142182418_.gif" alt="$$g^*\equiv g+te+qg\equiv x^3+7x^2-x-7\pmod{25},$$" class="latex-display" width="580" height="20"> <img src="./latex/latex2png-PolyFacZ_181708087_.gif" alt="$$h^*\equiv h+r\equiv x-7\pmod{25},$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_23704815_.gif" alt="$$b\equiv sg^*+th^*-1\equiv -5x^2-10x-5,$$" class="latex-display" width="580" height="19"> <img src="./latex/latex2png-PolyFacZ_149380899_.gif" alt="$$c=10x-10,\quad d=-10,$$" class="latex-display" width="580" height="16"> <img src="./latex/latex2png-PolyFacZ_156062044_.gif" alt="$$s^*\equiv s-d\equiv 8\pmod{25},$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_36323292_.gif" alt="$$t^*\equiv t-tb-cg^*\equiv -8x^2-12x-1.$$" class="latex-display" width="580" height="19"></p>

<p>正如Hensel单步提升算法所提到的,我们有<img src="./latex/latex2png-PolyFacZ_93648659_-4.gif" alt="$\deg g^*=\deg g$" class="latex-inline" style="vertical-align: -4px" width="102" height="16">,<img src="./latex/latex2png-PolyFacZ_94762771_-4.gif" alt="$\deg h^*=\deg h$" class="latex-inline" style="vertical-align: -4px" width="104" height="16">.</p>


</div>

<p>如果我们归纳地利用单步Hensel算法,依次对<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">,<img src="./latex/latex2png-PolyFacZ_185889812_0.gif" alt="$m^2$" class="latex-inline" style="vertical-align: 0px" width="21" height="14">,<img src="./latex/latex2png-PolyFacZ_186020884_0.gif" alt="$m^4$" class="latex-inline" style="vertical-align: 0px" width="21" height="14">,<img src="./latex/latex2png-PolyFacZ_202219025_3.gif" alt="$\cdots$" class="latex-inline" style="vertical-align: 3px" width="17" height="2">使用，则对任何正整数<img src="./latex/latex2png-PolyFacZ_42365970_0.gif" alt="$l$" class="latex-inline" style="vertical-align: 0px" width="4" height="12">，我们总可找到比其大的<img src="./latex/latex2png-PolyFacZ_41186322_0.gif" alt="$2$" class="latex-inline" style="vertical-align: 0px" width="8" height="11">的幂次，于是有下面的：</p>

<div class="theorem">
<span class="theorem-header">定理2<a name="th:helsellemma"></a></span><span class="theorem-name">(Hensel引理)</span>
对于给定的正整数<img src="./latex/latex2png-PolyFacZ_42365970_0.gif" alt="$l$" class="latex-inline" style="vertical-align: 0px" width="4" height="12">以及算法<a class="ref-th" href="#al:henselstep">3</a>中输入的条件,我们可以将<img src="./latex/latex2png-PolyFacZ_185889812_0.gif" alt="$m^2$" class="latex-inline" style="vertical-align: 0px" width="21" height="14">用<img src="./latex/latex2png-PolyFacZ_187069460_0.gif" alt="$m^l$" class="latex-inline" style="vertical-align: 0px" width="19" height="14">代替，仍然得到满足条件的输出.


</div>

<div class="theorem">
<span class="theorem-header">定理3<a name="th:henseluniqueness"></a></span><span class="theorem-name">(Hensel提升的唯一性)</span>
对于非零整数<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">和正整数<img src="./latex/latex2png-PolyFacZ_42365970_0.gif" alt="$l$" class="latex-inline" style="vertical-align: 0px" width="4" height="12">以及非零多项式<img src="./latex/latex2png-PolyFacZ_242949774_-5.gif" alt="$g,h,g^*,h^*,s,t\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="150" height="18">,其中<img src="./latex/latex2png-PolyFacZ_136018659_-5.gif" alt="$sg+th\equiv 1\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="153" height="18">,<img src="./latex/latex2png-PolyFacZ_60144229_-5.gif" alt="$\mathrm{lc}(g)$" class="latex-inline" style="vertical-align: -5px" width="32" height="18">和<img src="./latex/latex2png-PolyFacZ_59095653_-5.gif" alt="$\mathrm{lc}(h)$" class="latex-inline" style="vertical-align: -5px" width="33" height="18">不是<img src="./latex/latex2png-PolyFacZ_68661813_-2.gif" alt="$\mathbb{Z}_m$" class="latex-inline" style="vertical-align: -2px" width="23" height="14">中的零因子,<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">和<img src="./latex/latex2png-PolyFacZ_84702228_-4.gif" alt="$g^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">有同样的领项和次数，且模<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">同余，对于<img src="./latex/latex2png-PolyFacZ_42103826_0.gif" alt="$h$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">和<img src="./latex/latex2png-PolyFacZ_101479444_0.gif" alt="$h^*$" class="latex-inline" style="vertical-align: 0px" width="16" height="12">有相似的条件.此时若<img src="./latex/latex2png-PolyFacZ_81018835_-5.gif" alt="$gh\equiv g^*h^*\pmod{m^l}$" class="latex-inline" style="vertical-align: -5px" width="149" height="19">,则<img src="./latex/latex2png-PolyFacZ_75854323_-5.gif" alt="$g\equiv g^*\pmod{m^l}$" class="latex-inline" style="vertical-align: -5px" width="123" height="19">,<img src="./latex/latex2png-PolyFacZ_75854325_-5.gif" alt="$h\equiv h^*\pmod{m^l}$" class="latex-inline" style="vertical-align: -5px" width="125" height="19">.


</div>

<div class="proof">
<span class="proof-header">证明</span>
假设结论不成立,即<img src="./latex/latex2png-PolyFacZ_118127152_-5.gif" alt="$g\not\equiv g^*\pmod{m^l}$" class="latex-inline" style="vertical-align: -5px" width="123" height="19">或<img src="./latex/latex2png-PolyFacZ_118192689_-5.gif" alt="$h\not\equiv h^*\pmod{m^l}$" class="latex-inline" style="vertical-align: -5px" width="125" height="19">,不妨假设前者不成立,于是我们可以找到最大的指标<img src="./latex/latex2png-PolyFacZ_199066616_-5.gif" alt="$i(1\le i<l)$" class="latex-inline" style="vertical-align: -5px" width="81" height="18">使得<img src="./latex/latex2png-PolyFacZ_141059436_-5.gif" alt="$m^i|g-g^*$" class="latex-inline" style="vertical-align: -5px" width="68" height="19">且<img src="./latex/latex2png-PolyFacZ_124282219_-5.gif" alt="$m^i|h-h^*$" class="latex-inline" style="vertical-align: -5px" width="71" height="19">，不妨设<img src="./latex/latex2png-PolyFacZ_57951556_-4.gif" alt="$g^*-g=um^i$" class="latex-inline" style="vertical-align: -4px" width="97" height="18">,<img src="./latex/latex2png-PolyFacZ_209435308_0.gif" alt="$h^*-h=vm^i$" class="latex-inline" style="vertical-align: 0px" width="98" height="14">且<img src="./latex/latex2png-PolyFacZ_26345244_-5.gif" alt="$m\not|u$" class="latex-inline" style="vertical-align: -5px" width="38" height="18">.则<img src="./latex/latex2png-PolyFacZ_192150906_.gif" alt="$$0\equiv g^*h^*-gh\equiv g^*(h^*-h)+h(g^*-g)\equiv (g^*v+hu)m^i\pmod{m^l},$$" class="latex-display" width="580" height="20"> 于是<img src="./latex/latex2png-PolyFacZ_166919286_-5.gif" alt="$m|m^{l-i}|(g^*v+hu)$" class="latex-inline" style="vertical-align: -5px" width="135" height="19">,若<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">将模<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">的象以<img src="./latex/latex2png-PolyFacZ_212247402_-4.gif" alt="$\overline{f}$" class="latex-inline" style="vertical-align: -4px" width="10" height="19">来记，则有<img src="./latex/latex2png-PolyFacZ_69304222_.gif" alt="$$\overline{sg}+\overline{th}=1,\quad \overline{g^*}=\overline{g},\quad \overline{g^*v}+\overline{hu}=0.$$" class="latex-display" width="580" height="19"> 因此<img src="./latex/latex2png-PolyFacZ_194336786_.gif" alt="$$0=\overline{t}(\overline{g^*v}+\overline{hu})=\overline{tgv}+(1-\overline{sg})\overline{u}=(\overline{tv}-\overline{su})\overline{g}+\overline{u},$$" class="latex-display" width="580" height="20"> 于是<img src="./latex/latex2png-PolyFacZ_57896140_-5.gif" alt="$\overline{g}|\overline{u}$" class="latex-inline" style="vertical-align: -5px" width="24" height="18">,又<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">和<img src="./latex/latex2png-PolyFacZ_84702228_-4.gif" alt="$g^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">的领项和次数均相同,我们有<img src="./latex/latex2png-PolyFacZ_88480908_-4.gif" alt="$\deg\overline{u}<\deg\overline{g}$" class="latex-inline" style="vertical-align: -4px" width="96" height="16">,于是由整除性知<img src="./latex/latex2png-PolyFacZ_183171142_-1.gif" alt="$\overline{u}=0$" class="latex-inline" style="vertical-align: -1px" width="40" height="12">,这与<img src="./latex/latex2png-PolyFacZ_26345244_-5.gif" alt="$m\not|u$" class="latex-inline" style="vertical-align: -5px" width="38" height="18">矛盾.
<span class="proof-end">□</span>

</div>

<p>前面所说的均是二因子的Hensel提升,为了做多因子的情况，我们先给出如下定义：</p>

<div class="definition">
<span class="theorem-header">定义2<a name=""></a></span><span class="theorem-name">(因子树(Factor Tree))</span>
对于<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">中的多项式<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,以及正整数<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">(例如我们可以取作素数<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">),设有整数<img src="./latex/latex2png-PolyFacZ_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">使得<img src="./latex/latex2png-PolyFacZ_197220073_-5.gif" alt="$a\mathrm{lc}(f)\equiv 1\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="145" height="18">,则<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">模<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">的因子树(factor tree of f modulo m)是指一个二叉树<img src="./latex/latex2png-PolyFacZ_266302524_0.gif" alt="$\tau$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">:其根结点是<img src="./latex/latex2png-PolyFacZ_131101714_-4.gif" alt="$af$" class="latex-inline" style="vertical-align: -4px" width="18" height="16">;每个结点的两个子结点均是该结点在<img src="./latex/latex2png-PolyFacZ_197024685_-5.gif" alt="$\mathbb{Z}_m[x]$" class="latex-inline" style="vertical-align: -5px" width="41" height="18">中的非平凡首一因子;叶结点均为<img src="./latex/latex2png-PolyFacZ_197024685_-5.gif" alt="$\mathbb{Z}_m[x]$" class="latex-inline" style="vertical-align: -5px" width="41" height="18">的不可约因子.


</div>

<div class="remark">
<span class="proof-header">注1<a name=""></a></span><span class="theorem-name"></span>
实际我们有模素数的因子分解生成因子树时,需要用扩展Euclid算法算出各个属于同一中间结点的两个子结点的Bezout系数,以便进行下面的多因子Hensel提升算法.一个典型的因子树如下图所示.其中每个结点的括号中显示了其相应的Bezout系数.


</div>

<table class="image" width="100%">
  <tr><td align="center"><img src="images/factortree.png" alt="模5因子树"></td></tr>
  <tr><td align="center" class="image-caption">模5因子树</td></tr>
</table>

<p>当然由模<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">的因子树我们可以由单步Hensel算法得到模<img src="./latex/latex2png-PolyFacZ_185889812_0.gif" alt="$m^2$" class="latex-inline" style="vertical-align: 0px" width="21" height="14">乃至更高次幂的因子树,只要我们由根结点依次一步步在每个结点做Hensel提升即可.下面给出该算法：</p>

<div class="algorithm">
<span class="theorem-header">算法4<a name="al:multifactorhensellifting"></a></span><span class="theorem-name">(多因子Hensel提升)</span>

<p>输入：整数<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">和<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">次多项式<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">,<img src="./latex/latex2png-PolyFacZ_181909840_-3.gif" alt="$a_0\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -3px" width="48" height="15">使得<img src="./latex/latex2png-PolyFacZ_155496425_-5.gif" alt="$a_0\mathrm{lc}(f)\equiv 1\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="153" height="18">,正整数<img src="./latex/latex2png-PolyFacZ_42365970_0.gif" alt="$l$" class="latex-inline" style="vertical-align: 0px" width="4" height="12">,一个<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">模<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">的因子树<img src="./latex/latex2png-PolyFacZ_266302524_0.gif" alt="$\tau$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">,共有<img src="./latex/latex2png-PolyFacZ_42759186_0.gif" alt="$r$" class="latex-inline" style="vertical-align: 0px" width="7" height="8">个叶子.</p>

<p>输出：整数<img src="./latex/latex2png-PolyFacZ_15961068_0.gif" alt="$a^*$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">使得<img src="./latex/latex2png-PolyFacZ_106789352_-5.gif" alt="$a^*\mathrm{lc}(f)\equiv 1\pmod{m^l}$" class="latex-inline" style="vertical-align: -5px" width="158" height="19">和一个<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">模<img src="./latex/latex2png-PolyFacZ_187069460_0.gif" alt="$m^l$" class="latex-inline" style="vertical-align: 0px" width="19" height="14">的因子树<img src="./latex/latex2png-PolyFacZ_51158561_0.gif" alt="$\tau^*$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">,各个新结点<img src="./latex/latex2png-PolyFacZ_200510444_0.gif" alt="$v^*$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">和原结点<img src="./latex/latex2png-PolyFacZ_43021330_0.gif" alt="$v$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">满足<img src="./latex/latex2png-PolyFacZ_202080913_-5.gif" alt="$v^*\equiv v\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="118" height="18">.</p>

<ol>
<li><img src="./latex/latex2png-PolyFacZ_220722752_-5.gif" alt="$d=\lceil\log_2l\rceil$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">,<img src="./latex/latex2png-PolyFacZ_253909417_-3.gif" alt="$\tau_0=\tau$" class="latex-inline" style="vertical-align: -3px" width="46" height="11">,</li>

<li>对<img src="./latex/latex2png-PolyFacZ_42234898_-4.gif" alt="$j$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">从<img src="./latex/latex2png-PolyFacZ_41120786_0.gif" alt="$1$" class="latex-inline" style="vertical-align: 0px" width="6" height="11">循环到<img src="./latex/latex2png-PolyFacZ_41841682_0.gif" alt="$d$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">,执行3～5步,</li>

<li>计算整数<img src="./latex/latex2png-PolyFacZ_13339628_-5.gif" alt="$a_j$" class="latex-inline" style="vertical-align: -5px" width="15" height="13">使得<img src="./latex/latex2png-PolyFacZ_243161174_-7.gif" alt="$a_j\equiv 2a_{j-1}-\mathrm{lc}(f)a_{j-1}^2\pmod{m^{2^j}}$" class="latex-inline" style="vertical-align: -7px" width="251" height="24">,<img src="./latex/latex2png-PolyFacZ_166177396_-5.gif" alt="$\tau_j=\tau_{j-1}$" class="latex-inline" style="vertical-align: -5px" width="66" height="13">,将<img src="./latex/latex2png-PolyFacZ_53780001_-5.gif" alt="$\tau_j$" class="latex-inline" style="vertical-align: -5px" width="13" height="13">的根结点换为<img src="./latex/latex2png-PolyFacZ_211782599_-5.gif" alt="$a_jf$" class="latex-inline" style="vertical-align: -5px" width="25" height="17">,</li>

<li>从根结点遍历<img src="./latex/latex2png-PolyFacZ_53780001_-5.gif" alt="$\tau_j$" class="latex-inline" style="vertical-align: -5px" width="13" height="13">的结点,对每个非叶结点<img src="./latex/latex2png-PolyFacZ_43021330_0.gif" alt="$v$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">,执行第5步（由根向叶结点方向进行）,</li>

<li>调用算法<a class="ref-th" href="#al:henselstep">3</a>,输入<img src="./latex/latex2png-PolyFacZ_237111415_0.gif" alt="$m^{2^{j-1}}$" class="latex-inline" style="vertical-align: 0px" width="41" height="17">来提升<img src="./latex/latex2png-PolyFacZ_107582822_-4.gif" alt="$v=g_vh_v$" class="latex-inline" style="vertical-align: -4px" width="64" height="16">和<img src="./latex/latex2png-PolyFacZ_221306178_-5.gif" alt="$s_vg_v+t_vh_v\equiv 1\pmod{m^{2^{j-1}}}$" class="latex-inline" style="vertical-align: -5px" width="212" height="22">,提升到模<img src="./latex/latex2png-PolyFacZ_97342827_0.gif" alt="$m^{2^{j}}$" class="latex-inline" style="vertical-align: 0px" width="27" height="17">,</li>

<li>输出<img src="./latex/latex2png-PolyFacZ_13732844_-2.gif" alt="$a_d$" class="latex-inline" style="vertical-align: -2px" width="16" height="10">,<img src="./latex/latex2png-PolyFacZ_53386785_-2.gif" alt="$\tau_d$" class="latex-inline" style="vertical-align: -2px" width="14" height="10">.</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注2<a name=""></a></span><span class="theorem-name"></span>
注意到<img src="./latex/latex2png-PolyFacZ_41841682_0.gif" alt="$d$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">的选取能够使我将因子树提升到足够高的次数.


</div>

<div class="remark">
<span class="proof-header">注3<a name=""></a></span><span class="theorem-name"></span>
我们只需要说明每一步求得的<img src="./latex/latex2png-PolyFacZ_13339628_-5.gif" alt="$a_j$" class="latex-inline" style="vertical-align: -5px" width="15" height="13">确实满足要求.这是因为<img src="./latex/latex2png-PolyFacZ_107210208_-7.gif" alt="$a_j\mathrm{lc}(f)\equiv 2a_{j-1}\mathrm{lc}(f)-\mathrm{lc}^2(f)a_{j-1}^2\equiv 1-(1-a_{j-1}\mathrm{lc}(f))^2\equiv 1\pmod{m^{2^j}}$" class="latex-inline" style="vertical-align: -7px" width="526" height="24">.


</div>


<h2><a name="sec3" id="sec3"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>应用Hensel提升的Zasenhaus算法</h2>

<p class="first">有了前面的Hensel提升理论,下面我们就可以利用它取代前面的大素数模算法.</p>

<div class="algorithm">
<span class="theorem-header">算法5<a name="al:primepower3"></a></span><span class="theorem-name">(整系数多项式分解3:素数幂和因子组合算法)</span>

<p>输入：一个无平方因子本原<img src="./latex/latex2png-PolyFacZ_75658260_0.gif" alt="$ n $" class="latex-inline" style="vertical-align: 0px" width="10" height="8">次多项式<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">,<img src="./latex/latex2png-PolyFacZ_68944530_-5.gif" alt="$\mathrm{lc}(f)>0$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">且<img src="./latex/latex2png-PolyFacZ_231597701_-5.gif" alt="$\|f\|_{\infty}=A$" class="latex-inline" style="vertical-align: -5px" width="74" height="18">,</p>

<p>输出：<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的不可约因子<img src="./latex/latex2png-PolyFacZ_21450496_-5.gif" alt="$\{f_1,\ldots,f_k\}\subset\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="135" height="18">.</p>

<ol>
<li>若<img src="./latex/latex2png-PolyFacZ_167998484_0.gif" alt="$n=1$" class="latex-inline" style="vertical-align: 0px" width="39" height="11">则输出<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,否则<img src="./latex/latex2png-PolyFacZ_58589541_-5.gif" alt="$b=\mathrm{lc}(f)$" class="latex-inline" style="vertical-align: -5px" width="63" height="18">,<img src="./latex/latex2png-PolyFacZ_101737598_-5.gif" alt="$B=(n+1)^{1/2}2^nAb$" class="latex-inline" style="vertical-align: -5px" width="144" height="20">,<img src="./latex/latex2png-PolyFacZ_115985300_-5.gif" alt="$C=(n+1)^{2n}A^{2n-1}$" class="latex-inline" style="vertical-align: -5px" width="144" height="19">,<img src="./latex/latex2png-PolyFacZ_23605766_-5.gif" alt="$\gamma=\lceil 2\log_2C\rceil$" class="latex-inline" style="vertical-align: -5px" width="100" height="18">,</li>

<li>任意选取素数<img src="./latex/latex2png-PolyFacZ_93355312_-4.gif" alt="$p\le 2\gamma\ln\gamma$" class="latex-inline" style="vertical-align: -4px" width="78" height="16">,<img src="./latex/latex2png-PolyFacZ_155408431_-4.gif" alt="$\overline{f}=f \bmod p$" class="latex-inline" style="vertical-align: -4px" width="91" height="19">,直到<img src="./latex/latex2png-PolyFacZ_25100828_-5.gif" alt="$p\not|b$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">且<img src="./latex/latex2png-PolyFacZ_16859241_-5.gif" alt="$\gcd(\overline{f},\overline{f}')=1\in\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="155" height="23">,然后令<img src="./latex/latex2png-PolyFacZ_170946636_-7.gif" alt="$l=\lceil\log_p(2B+1)\rceil$" class="latex-inline" style="vertical-align: -7px" width="131" height="20">,</li>

<li>调用有限域上因子分解算法计算<img src="./latex/latex2png-PolyFacZ_111906258_-5.gif" alt="$h_1,\ldots,h_r\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="119" height="18">,各因子均是首一不可约因子,且无穷范数小于<img src="./latex/latex2png-PolyFacZ_186938388_-5.gif" alt="$p/2$" class="latex-inline" style="vertical-align: -5px" width="25" height="18">,于是<img src="./latex/latex2png-PolyFacZ_53262560_-5.gif" alt="$f\equiv bh_1\cdots h_r\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="161" height="18">,</li>

<li><img src="./latex/latex2png-PolyFacZ_72589579_-4.gif" alt="$a=b^{-1}\bmod p$" class="latex-inline" style="vertical-align: -4px" width="105" height="18">,利用扩展Euclid算法建立<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">模<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">的因子树,叶结点为<img src="./latex/latex2png-PolyFacZ_138717314_-4.gif" alt="$h_1,\ldots,h_r$" class="latex-inline" style="vertical-align: -4px" width="70" height="16">,再调用算法<a class="ref-th" href="#al:multifactorhensellifting">4</a>计算分解<img src="./latex/latex2png-PolyFacZ_136560204_-5.gif" alt="$f\equiv bg_1\cdots g_r\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="163" height="19">,其中<img src="./latex/latex2png-PolyFacZ_60447076_-5.gif" alt="$g_i\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="62" height="18">为首一且无穷范数小于<img src="./latex/latex2png-PolyFacZ_119830176_-5.gif" alt="$p^l/2$" class="latex-inline" style="vertical-align: -5px" width="30" height="19">,<img src="./latex/latex2png-PolyFacZ_183475054_-5.gif" alt="$g_i\equiv h_i\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="115" height="18">,</li>

<li>调用因子组合算法并输出.(此处同算法<a class="ref-th" href="#al:bpfc1">1</a>第4～10步.) <img src="./latex/latex2png-PolyFacZ_230096074_-5.gif" alt="$T=\{1,\ldots,r\}$" class="latex-inline" style="vertical-align: -5px" width="103" height="18">,<img src="./latex/latex2png-PolyFacZ_251884564_0.gif" alt="$s=1$" class="latex-inline" style="vertical-align: 0px" width="36" height="11">,<img src="./latex/latex2png-PolyFacZ_172920293_-2.gif" alt="$G=\emptyset$" class="latex-inline" style="vertical-align: -2px" width="42" height="15">,<img src="./latex/latex2png-PolyFacZ_235959958_-4.gif" alt="$f^*=f$" class="latex-inline" style="vertical-align: -4px" width="48" height="16">,</li>

<li>当<img src="./latex/latex2png-PolyFacZ_246277402_-4.gif" alt="$2s\le\#T$" class="latex-inline" style="vertical-align: -4px" width="64" height="16">时循环执行下面4步，否则转第11步,</li>

<li>枚举<img src="./latex/latex2png-PolyFacZ_43414546_0.gif" alt="$T$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">的所有<img src="./latex/latex2png-PolyFacZ_42824722_0.gif" alt="$s$" class="latex-inline" style="vertical-align: 0px" width="6" height="8">元子集<img src="./latex/latex2png-PolyFacZ_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13">,并做下两步8、9循环：</li>

<li>计算<img src="./latex/latex2png-PolyFacZ_84702228_-4.gif" alt="$g^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">,<img src="./latex/latex2png-PolyFacZ_74668388_-5.gif" alt="$h^*\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">使得其无穷范数比<img src="./latex/latex2png-PolyFacZ_119830176_-5.gif" alt="$p^l/2$" class="latex-inline" style="vertical-align: -5px" width="30" height="19">要小并且<img src="./latex/latex2png-PolyFacZ_183064667_-7.gif" alt="$g^*\equiv b\prod_{i\in S}g_i\pmod{p^l}$" class="latex-inline" style="vertical-align: -7px" width="173" height="21">,<img src="./latex/latex2png-PolyFacZ_158146780_-8.gif" alt="$h^*\equiv b\prod_{i\in T\setminus S}g_i\pmod{p^l}$" class="latex-inline" style="vertical-align: -8px" width="190" height="22">,</li>

<li>若<img src="./latex/latex2png-PolyFacZ_261955809_-5.gif" alt="$\|g^*\|_1\|h^*\|_1\le B$" class="latex-inline" style="vertical-align: -5px" width="116" height="18">则<img src="./latex/latex2png-PolyFacZ_28858641_-5.gif" alt="$T=T\setminus S$" class="latex-inline" style="vertical-align: -5px" width="73" height="18">,<img src="./latex/latex2png-PolyFacZ_2938495_-5.gif" alt="$G=G\bigcup\{\mathrm{pp}(g^*)\}$" class="latex-inline" style="vertical-align: -5px" width="126" height="18">,<img src="./latex/latex2png-PolyFacZ_262780266_-5.gif" alt="$f^*=\mathrm{pp}(h^*)$" class="latex-inline" style="vertical-align: -5px" width="86" height="18">,<img src="./latex/latex2png-PolyFacZ_145359506_-5.gif" alt="$b=\mathrm{lc}(f^*)$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">,跳出7、8、9循环并转第6步,</li>

<li><img src="./latex/latex2png-PolyFacZ_35424607_-2.gif" alt="$s=s+1$" class="latex-inline" style="vertical-align: -2px" width="64" height="13">,</li>

<li>输出<img src="./latex/latex2png-PolyFacZ_52159108_-5.gif" alt="$G\bigcup\{f^*\}$" class="latex-inline" style="vertical-align: -5px" width="62" height="18">.</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注4<a name=""></a></span><span class="theorem-name"></span>
步骤2中<img src="./latex/latex2png-PolyFacZ_108290540_-4.gif" alt="$\gamma$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">的引入见<span class="cite"><a class="cite" href="#ref-1" name="cite-1">[1]</a></span>18.4节.


</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法正确性)</span>
记<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的因子<img src="./latex/latex2png-PolyFacZ_16144738_-5.gif" alt="$u\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="58" height="18">,其在<img src="./latex/latex2png-PolyFacZ_71410771_-5.gif" alt="$\mathbb{Z}_p[x]$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">中不可约因子个数<img src="./latex/latex2png-PolyFacZ_50618853_-5.gif" alt="$\mu(u)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">.现在我们要归纳证明在每次到第6步时，有下面命题成立：

<ol>
<li><img src="./latex/latex2png-PolyFacZ_254282692_-8.gif" alt="$f^*\equiv b\prod_{i\in T}g_i\pmod{p^l},\quad b=\mathrm{lc}(f^*),\quad f=f^*\prod_{g\in G}g$" class="latex-inline" style="vertical-align: -8px" width="401" height="22">,</li>

<li><img src="./latex/latex2png-PolyFacZ_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">中多项式均不可约,</li>

<li><img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">本原且它的任何一个不可约因子<img src="./latex/latex2png-PolyFacZ_16213090_-5.gif" alt="$u\in\mathrm{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">有<img src="./latex/latex2png-PolyFacZ_267207684_-5.gif" alt="$\mu(u)\ge s$" class="latex-inline" style="vertical-align: -5px" width="62" height="18">.</li>
</ol>

<p>主要证法和算法<a class="ref-th" href="#al:bpfc1">1</a>的证明一致,我们只需证明当<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">有一个不可约因子<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">满足<img src="./latex/latex2png-PolyFacZ_45646322_-5.gif" alt="$\mu(g)=s$" class="latex-inline" style="vertical-align: -5px" width="61" height="18">时，当循环到s时必然能将此因子选出，这一点可以构造来证明，即取指标集<img src="./latex/latex2png-PolyFacZ_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13">为<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">在<img src="./latex/latex2png-PolyFacZ_223283783_-5.gif" alt="$\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="35" height="18">中不可约因子的编号.当然这里与前面的证法有所不同,因为<img src="./latex/latex2png-PolyFacZ_10614301_-6.gif" alt="$\mathbb{Z}_{p^l}[x]$" class="latex-inline" style="vertical-align: -6px" width="41" height="19">并不是UFD,要证明唯一性还需要用Hensel提升的唯一性定理.首先可设<img src="./latex/latex2png-PolyFacZ_190755030_-7.gif" alt="$\mathrm{lc}(h)g\equiv b\prod_{i\in S}g_i\pmod{p}$" class="latex-inline" style="vertical-align: -7px" width="194" height="20">,<img src="./latex/latex2png-PolyFacZ_55675505_-8.gif" alt="$\mathrm{lc}(g)h\equiv b\prod_{i\in T\setminus S}g_i\pmod{p}$" class="latex-inline" style="vertical-align: -8px" width="211" height="21">,再设<img src="./latex/latex2png-PolyFacZ_183064667_-7.gif" alt="$g^*\equiv b\prod_{i\in S}g_i\pmod{p^l}$" class="latex-inline" style="vertical-align: -7px" width="173" height="21">,<img src="./latex/latex2png-PolyFacZ_158146780_-8.gif" alt="$h^*\equiv b\prod_{i\in T\setminus S}g_i\pmod{p^l}$" class="latex-inline" style="vertical-align: -8px" width="190" height="22">.由<img src="./latex/latex2png-PolyFacZ_20094034_-4.gif" alt="$f^*=gh$" class="latex-inline" style="vertical-align: -4px" width="56" height="16">可知
<img src="./latex/latex2png-PolyFacZ_187036477_.gif" alt="$$bf^*=\plc{h}g\plc{g}h,$$" class="latex-display" width="580" height="18">
另外
<img src="./latex/latex2png-PolyFacZ_164804248_.gif" alt="$$bf^*\equiv g^*h^*\pmod{p^l},$$" class="latex-display" width="580" height="20">
以上两式均是<img src="./latex/latex2png-PolyFacZ_210465790_-4.gif" alt="$bf^*\bmod p$" class="latex-inline" style="vertical-align: -4px" width="74" height="16">的提升,于是<img src="./latex/latex2png-PolyFacZ_219887409_-5.gif" alt="$\mathrm{lc}(h)g\equiv g^*\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="151" height="19">且<img src="./latex/latex2png-PolyFacZ_219887155_-5.gif" alt="$\mathrm{lc}(g)h\equiv h^*\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="152" height="19">,再由所定的Mignotte界和<img src="./latex/latex2png-PolyFacZ_73561108_0.gif" alt="$ l $" class="latex-inline" style="vertical-align: 0px" width="4" height="12">的选择可知9中的条件必然成立.
<span class="proof-end">□</span></p>

</div>

<div class="problem">
<span class="proof-header">例3<a name="example:factorization2"></a></span><span class="theorem-name"></span>
仍然考虑例<a class="ref-th" href="#example:factorization1">1</a>中<img src="./latex/latex2png-PolyFacZ_86175106_-5.gif" alt="$f=4x^4+13x^3+28x^2+27x+18\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="296" height="19">的分解.
<span class="example-end">◇</span>

</div>

<div class="solution">
<span class="proof-header">解</span>
首先,<img src="./latex/latex2png-PolyFacZ_168195092_0.gif" alt="$n=4$" class="latex-inline" style="vertical-align: 0px" width="40" height="11">,<img src="./latex/latex2png-PolyFacZ_262507462_-1.gif" alt="$A=28$" class="latex-inline" style="vertical-align: -1px" width="51" height="13">,<img src="./latex/latex2png-PolyFacZ_33131500_0.gif" alt="$b=4$" class="latex-inline" style="vertical-align: 0px" width="37" height="12">,<img src="./latex/latex2png-PolyFacZ_44479365_-2.gif" alt="$B=1792\sqrt{5}=4007.03$" class="latex-inline" style="vertical-align: -2px" width="166" height="17">,<img src="./latex/latex2png-PolyFacZ_238636447_-4.gif" alt="$\gamma=104$" class="latex-inline" style="vertical-align: -4px" width="56" height="15">,而<img src="./latex/latex2png-PolyFacZ_96697590_-5.gif" alt="$2,3|\mathrm{disc}(f)$" class="latex-inline" style="vertical-align: -5px" width="78" height="18">,故取<img src="./latex/latex2png-PolyFacZ_201815060_-4.gif" alt="$p=5$" class="latex-inline" style="vertical-align: -4px" width="39" height="15">,此时<img src="./latex/latex2png-PolyFacZ_234579140_-5.gif" alt="$l=\lceil\log_5(2B+1)\rceil=6$" class="latex-inline" style="vertical-align: -5px" width="164" height="18">,要提升3次.首先利用模<img src="./latex/latex2png-PolyFacZ_41382930_-1.gif" alt="$5$" class="latex-inline" style="vertical-align: -1px" width="8" height="12">因子分解和扩展Euclid算法得到如下模5因子树：

<p class="image"><img src="./latex/latex2png-PolyFacZ_223991662_.gif" alt="
\begin{equation*}
4f=
\begin{cases}
s=x,g=x^2-1\begin{cases}s=3,g=x+1\\t=2,h=x-1\end{cases}\\
t=-x+2,h=x^2+2x-2
\end{cases}
\end{equation*}
" class="latex-display" width="580" height="91"></p>

<p>利用多因子提升算法提升为模25因子树：</p>

<p class="image"><img src="./latex/latex2png-PolyFacZ_131679899_.gif" alt="
\begin{equation*}
19f=\begin{cases}
s=6x,g=x^2-5x-11\begin{cases}s=-2,g=x-9\\t=2,h=x+4\end{cases}\\
t=-6x-8,h=x^2+2x+3
\end{cases}
\end{equation*}
" class="latex-display" width="580" height="91">
以此类推有模<img src="./latex/latex2png-PolyFacZ_156888874_-1.gif" alt="$5^4=625$" class="latex-inline" style="vertical-align: -1px" width="62" height="15">因子树：
<img src="./latex/latex2png-PolyFacZ_159193426_.gif" alt="
\begin{equation*}
469f=\begin{cases}
s=-69x,g=x^2-155x-311\begin{cases}s=-177,g=x-134\\t=177,h=x-21\end{cases}\\
t=69x-208,h=x^2+2x+3
\end{cases}
\end{equation*}
" class="latex-display" width="580" height="91">
模<img src="./latex/latex2png-PolyFacZ_17380478_-1.gif" alt="$5^8=390625$" class="latex-inline" style="vertical-align: -1px" width="86" height="15">因子树：
<img src="./latex/latex2png-PolyFacZ_26174969_.gif" alt="
\begin{equation*}
292969f=\begin{cases}
s=86806x,g=x^2-97655x-195311\begin{cases}s=-108927,g=x+82991\\t=108927,h=x-180646\end{cases}\\
t=-86806x-130208,h=x^2+2x+3
\end{cases}
\end{equation*}
" class="latex-display" width="580" height="91">
于是我们有<img src="./latex/latex2png-PolyFacZ_140216574_-5.gif" alt="$f\equiv 4(x+82991)(x-180646)(x^2+2x+3)\pmod{5^8}$" class="latex-inline" style="vertical-align: -5px" width="385" height="19">.这里我们再对其进行还原时，显然有<img src="./latex/latex2png-PolyFacZ_251884564_0.gif" alt="$s=1$" class="latex-inline" style="vertical-align: 0px" width="36" height="11">时可得到不可约因子<img src="./latex/latex2png-PolyFacZ_181303047_-5.gif" alt="$(x^2+2x+3)$" class="latex-inline" style="vertical-align: -5px" width="94" height="19">,此时<img src="./latex/latex2png-PolyFacZ_116990868_-5.gif" alt="$f^*=h^*\equiv 4(x+82991)(x-180646)\equiv 4x^2+5x+6\pmod{5^8}$" class="latex-inline" style="vertical-align: -5px" width="449" height="19">.于是再一次得到分解<img src="./latex/latex2png-PolyFacZ_192052703_-5.gif" alt="$f=(x^2+2x+3)(4x^2+5x+6)$" class="latex-inline" style="vertical-align: -5px" width="231" height="19">.</p>


</div>


<h2><a name="sec4" id="sec4"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>格中短向量(Short vectors in lattices)理论</h2>

<h3><a name="sec5" id="sec5"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>问题的引入</h3>

<p class="first">通过大素数模方法或Hensel提升方法,我们都可以得到多项式<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">在模某个整数<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">后的分解,即<img src="./latex/latex2png-PolyFacZ_33339615_-5.gif" alt="$f\equiv bg_1\cdots g_r\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="165" height="18">.这时候我们用因子组合的算法将它们拼起来还原.但是这种方法的效率有时候不会很高,如Swinnerton-Dyer多项式(见<span class="cite"><a class="cite" href="#ref-1" name="cite-1">[1]</a></span>15.3节).于是我们要发展一套更有效的方法,下面几节将要介绍的格中短向量方法是一种多项式时间算法.</p>

<p>由定义<a class="ref-th-external" href="PolyGCD.html#def:norm">13</a>，以下我们取默认的范数<img src="./latex/latex2png-PolyFacZ_68581043_-5.gif" alt="$\|f\|$" class="latex-inline" style="vertical-align: -5px" width="24" height="18">为2-范数,即<img src="./latex/latex2png-PolyFacZ_98101866_-5.gif" alt="$\|f\|_2$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">.我们将多项式的系数看作向量，则多项式范数等同于该向量的范数.</p>

<div class="lemma">
<span class="theorem-header">引理3<a name="le:shortvectors1"></a></span><span class="theorem-name"></span>
设<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,<img src="./latex/latex2png-PolyFacZ_15227234_-5.gif" alt="$g\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">分别是<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">,<img src="./latex/latex2png-PolyFacZ_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">次多项式,<img src="./latex/latex2png-PolyFacZ_16144738_-5.gif" alt="$u\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="58" height="18">是一非平凡首一多项式,<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">为一正整数,若在<img src="./latex/latex2png-PolyFacZ_197024685_-5.gif" alt="$\mathbb{Z}_m[x]$" class="latex-inline" style="vertical-align: -5px" width="41" height="18">中有<img src="./latex/latex2png-PolyFacZ_170623151_-5.gif" alt="$u|f\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="95" height="18">,<img src="./latex/latex2png-PolyFacZ_170688687_-5.gif" alt="$u|g\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="94" height="18">,<img src="./latex/latex2png-PolyFacZ_214110573_-5.gif" alt="$\|f\|^k\|g\|^n<m$" class="latex-inline" style="vertical-align: -5px" width="104" height="19">.则<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">和<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">有非平凡公因子.


</div>

<div class="proof">
<span class="proof-header">证明</span>
假设<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">没有非平凡的公因子,则在<img src="./latex/latex2png-PolyFacZ_27044295_-5.gif" alt="$\mathbb{Q}[x]$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">中有<img src="./latex/latex2png-PolyFacZ_47030236_-5.gif" alt="$\gcd(f,g)=1$" class="latex-inline" style="vertical-align: -5px" width="92" height="18">,由结式理论推论<a class="ref-th-external" href="PolyGCD.html#cor:resultant3">4</a>可知存在<img src="./latex/latex2png-PolyFacZ_42824722_0.gif" alt="$s$" class="latex-inline" style="vertical-align: 0px" width="6" height="8">,<img src="./latex/latex2png-PolyFacZ_16079202_-5.gif" alt="$t\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="54" height="18">使得<img src="./latex/latex2png-PolyFacZ_108691595_-5.gif" alt="$sf+tg\equiv\mathrm{res}(f,g)\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="203" height="18">,由于<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">在模<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">下能整除<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">和<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">，则<img src="./latex/latex2png-PolyFacZ_119230179_-5.gif" alt="$u|\mathrm{res}(f,g)\bmod m$" class="latex-inline" style="vertical-align: -5px" width="127" height="18">.但<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">是非平凡首一多项式,于是必有<img src="./latex/latex2png-PolyFacZ_182767345_-5.gif" alt="$\mathrm{res}(f,g)\equiv 0\pmod{m}$" class="latex-inline" style="vertical-align: -5px" width="160" height="18">,再由阿达马不等式有<img src="./latex/latex2png-PolyFacZ_164205202_-5.gif" alt="$|\mathrm{res}(f,g)|<\|f\|^k\|g\|^n<m$" class="latex-inline" style="vertical-align: -5px" width="194" height="19">,此即说明<img src="./latex/latex2png-PolyFacZ_72289009_-5.gif" alt="$\mathrm{res}(f,g)=0$" class="latex-inline" style="vertical-align: -5px" width="88" height="18">,与<img src="./latex/latex2png-PolyFacZ_73841301_-5.gif" alt="$\gcd(f,g)=1\in\mathbb{Q}[x]$" class="latex-inline" style="vertical-align: -5px" width="143" height="18">矛盾.于是二者在<img src="./latex/latex2png-PolyFacZ_27044286_-5.gif" alt="$\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="28" height="18">中有非平凡公因子.
<span class="proof-end">□</span>

</div>

<p>由前面我们已得出的分解结果和上面的引理,我们可以设想这样一种分解的想法。首先我们已经有待分解的<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">次多项式<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">和<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">在模<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">下的一个因子<img src="./latex/latex2png-PolyFacZ_16144738_-5.gif" alt="$u\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="58" height="18">,此时我们需要找到一个较“短”的<img src="./latex/latex2png-PolyFacZ_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">次多项式<img src="./latex/latex2png-PolyFacZ_15227234_-5.gif" alt="$g\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">使得<img src="./latex/latex2png-PolyFacZ_237293538_-5.gif" alt="$\|g\|^n<m\|f\|^{-k}$" class="latex-inline" style="vertical-align: -5px" width="113" height="19">,且<img src="./latex/latex2png-PolyFacZ_143670277_-5.gif" alt="$u|g\bmod m$" class="latex-inline" style="vertical-align: -5px" width="78" height="18">,于是可通过<img src="./latex/latex2png-PolyFacZ_222584066_-5.gif" alt="$\gcd(f,g)$" class="latex-inline" style="vertical-align: -5px" width="61" height="18">得到<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的一个非平凡因子.为了叙述方便,以后记号<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">既可以表示<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">次多项式,也可以表示<img src="./latex/latex2png-PolyFacZ_149124116_-2.gif" alt="$n+1$" class="latex-inline" style="vertical-align: -2px" width="37" height="13">维系数向量.引入下面的定义：</p>

<div class="definition">
<span class="theorem-header">定义3<a name=""></a></span><span class="theorem-name"></span>
设有正整数<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">和向量<img src="./latex/latex2png-PolyFacZ_141358507_-4.gif" alt="$f_1,\ldots,f_n\in\mathbb{R}^n$" class="latex-inline" style="vertical-align: -4px" width="109" height="16">,则<img src="./latex/latex2png-PolyFacZ_75634314_.gif" alt="$$L=\sum_{1\le i\le n}\mathbb{Z}f_i=\{\sum_{1\le i\le n}r_if_i|r_1,\ldots,r_n\in\mathbb{Z}\}$$" class="latex-display" width="580" height="40">称为格子(lattice)或由<img src="./latex/latex2png-PolyFacZ_104900706_-4.gif" alt="$f_1,\ldots,f_n$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">产生的<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">-模.<img src="./latex/latex2png-PolyFacZ_104900706_-4.gif" alt="$f_1,\ldots,f_n$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">称为<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">的基.而<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">的范数是指：<img src="./latex/latex2png-PolyFacZ_195948437_.gif" alt="$$|L|=|\det(f_1,\ldots,f_n)|\in\mathbb{R}.$$" class="latex-display" width="580" height="18">后面将看到范数的定义是与基的选择无关的.


</div>

<p>现在我们考虑寻找一个次数小于<img src="./latex/latex2png-PolyFacZ_42234898_-4.gif" alt="$j$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的多项式<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">,设<img src="./latex/latex2png-PolyFacZ_84255062_-1.gif" alt="$L\subset\mathbb{Z}^j$" class="latex-inline" style="vertical-align: -1px" width="50" height="15">是由<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">和<img src="./latex/latex2png-PolyFacZ_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">生成的,即<img src="./latex/latex2png-PolyFacZ_178301043_.gif" alt="$$L=\{g=qu+rm|q,r\in\mathbb{Z}[x],\deg q<j-d,\deg r<d\}.$$" class="latex-display" width="580" height="18">其中<img src="./latex/latex2png-PolyFacZ_243828974_-4.gif" alt="$d=\deg u$" class="latex-inline" style="vertical-align: -4px" width="68" height="16">,这时我们有下面的定理：</p>

<div class="theorem">
<span class="theorem-header">定理4<a name=""></a></span><span class="theorem-name"></span>
对于任何一个次数小于<img src="./latex/latex2png-PolyFacZ_42234898_-4.gif" alt="$j$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的多项式<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">,<img src="./latex/latex2png-PolyFacZ_199209198_-5.gif" alt="$u|g\bmod m\Leftrightarrow g\in L$" class="latex-inline" style="vertical-align: -5px" width="144" height="18">.


</div>

<div class="proof">
<span class="proof-header">证明</span>
对于<img src="./latex/latex2png-PolyFacZ_265901806_-1.gif" alt="$\Rightarrow$" class="latex-inline" style="vertical-align: -1px" width="15" height="10">显然,对于<img src="./latex/latex2png-PolyFacZ_120486128_-1.gif" alt="$\Leftarrow$" class="latex-inline" style="vertical-align: -1px" width="15" height="10">,我们有<img src="./latex/latex2png-PolyFacZ_67535636_-4.gif" alt="$g=q^*u+r^*m$" class="latex-inline" style="vertical-align: -4px" width="106" height="16">,再由<img src="./latex/latex2png-PolyFacZ_267619308_0.gif" alt="$r^*$" class="latex-inline" style="vertical-align: 0px" width="14" height="12">对首一多项式<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">的除法可得<img src="./latex/latex2png-PolyFacZ_49436168_-4.gif" alt="$r^*=q^{**}u+r^{**}$" class="latex-inline" style="vertical-align: -4px" width="111" height="16">(<span class="cite"><a class="cite" href="#ref-1" name="cite-1">[1]</a></span>中证明此处写作<img src="./latex/latex2png-PolyFacZ_252474388_-4.gif" alt="$q^*$" class="latex-inline" style="vertical-align: -4px" width="14" height="16">对<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">的除法),其中<img src="./latex/latex2png-PolyFacZ_249620638_-4.gif" alt="$\deg r^{**}<\deg u$" class="latex-inline" style="vertical-align: -4px" width="109" height="16">.令<img src="./latex/latex2png-PolyFacZ_66817902_-4.gif" alt="$q=q^*+mq^{**}$" class="latex-inline" style="vertical-align: -4px" width="102" height="16">,<img src="./latex/latex2png-PolyFacZ_48212459_0.gif" alt="$r=r^{**}$" class="latex-inline" style="vertical-align: 0px" width="51" height="12">,则有<img src="./latex/latex2png-PolyFacZ_1444049_-4.gif" alt="$g=qu+rm$" class="latex-inline" style="vertical-align: -4px" width="90" height="14">,且<img src="./latex/latex2png-PolyFacZ_252609887_-4.gif" alt="$\deg q<j-d$" class="latex-inline" style="vertical-align: -4px" width="95" height="16">,<img src="./latex/latex2png-PolyFacZ_237532195_-4.gif" alt="$\deg r<d$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">,于是<img src="./latex/latex2png-PolyFacZ_129065886_-4.gif" alt="$g\in L$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">.
<span class="proof-end">□</span>

</div>

<p>现在我们的问题化为在<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">中寻找一种约化的基,以使得基向量长度较短,满足要求.</p>


<h3><a name="sec6" id="sec6"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>约化基算法</h3>

<p class="first">下面要介绍的约化基算法即是所谓的3-L算法(Lenstra,Lenstra and Lov&aacute;sz).</p>

<div class="lemma">
<span class="theorem-header">引理4<a name=""></a></span><span class="theorem-name"></span>
令<img src="./latex/latex2png-PolyFacZ_184095868_-1.gif" alt="$N\subset M\subset \mathbb{R}^n$" class="latex-inline" style="vertical-align: -1px" width="97" height="13">为两个<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">-模，分别由<img src="./latex/latex2png-PolyFacZ_121088113_-4.gif" alt="$g_1,\cdots g_n$" class="latex-inline" style="vertical-align: -4px" width="61" height="12">和<img src="./latex/latex2png-PolyFacZ_104900706_-4.gif" alt="$f_1,\ldots,f_n$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">生成,则<img src="./latex/latex2png-PolyFacZ_114920428_-5.gif" alt="$|M|$" class="latex-inline" style="vertical-align: -5px" width="25" height="18">整除<img src="./latex/latex2png-PolyFacZ_113871852_-5.gif" alt="$|N|$" class="latex-inline" style="vertical-align: -5px" width="22" height="18">.


</div>

<div class="proof">
<span class="proof-header">证明</span>
由<img src="./latex/latex2png-PolyFacZ_126907649_-1.gif" alt="$N\subset M$" class="latex-inline" style="vertical-align: -1px" width="55" height="13">知<img src="./latex/latex2png-PolyFacZ_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">的生成元<img src="./latex/latex2png-PolyFacZ_87258132_-4.gif" alt="$g_i$" class="latex-inline" style="vertical-align: -4px" width="13" height="12">均是<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">的生成元<img src="./latex/latex2png-PolyFacZ_70480916_-4.gif" alt="$f_i$" class="latex-inline" style="vertical-align: -4px" width="12" height="16">的线性组合,即存在整系数矩阵<img src="./latex/latex2png-PolyFacZ_42169362_0.gif" alt="$A$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">使得<img src="./latex/latex2png-PolyFacZ_123339382_-5.gif" alt="$(g_1,\ldots,g_n)=A(f_1,\ldots,f_n)$" class="latex-inline" style="vertical-align: -5px" width="197" height="18">,于是<img src="./latex/latex2png-PolyFacZ_22444175_-5.gif" alt="$|N|=\det A|M|$" class="latex-inline" style="vertical-align: -5px" width="109" height="18">,<img src="./latex/latex2png-PolyFacZ_184457022_-4.gif" alt="$\deg A\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -4px" width="72" height="16">.
<span class="proof-end">□</span>

</div>

<p>若<img src="./latex/latex2png-PolyFacZ_232819692_0.gif" alt="$N=M$" class="latex-inline" style="vertical-align: 0px" width="55" height="12">,则有<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">-模的范数与生成元无关.由Hadamard不等式我们知道<img src="./latex/latex2png-PolyFacZ_246192057_-5.gif" alt="$|M|\le\|f_1\|\cdots\|f_n\|$" class="latex-inline" style="vertical-align: -5px" width="138" height="18">.</p>

<p>因为范数与基的选择无关,因而我们想到,如果选取的基越“正交”,那么某种程度上这组基矢的长度越短.因而,向量基的正交化可以启示我们得到一种求约化基（即所谓的短矢量）的方法.</p>

<p>现在我们已知由<img src="./latex/latex2png-PolyFacZ_104900706_-4.gif" alt="$f_1,\ldots,f_n$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">生成的<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">-模,即一个<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">维格子,若取内积为<img src="./latex/latex2png-PolyFacZ_186806875_-5.gif" alt="$\langle f,g\rangle=f^Tg$" class="latex-inline" style="vertical-align: -5px" width="87" height="19">,由高等代数学(见<span class="cite"><a class="cite" href="#ref-2" name="cite-2">[2]</a></span>P281)的内容我们知道可以对它们进行Gram-Schmidt正交化,正交化的过程可以归纳地进行,即令<img src="./latex/latex2png-PolyFacZ_156787936_-4.gif" alt="$f_1^*=f_1$" class="latex-inline" style="vertical-align: -4px" width="53" height="16">,对于<img src="./latex/latex2png-PolyFacZ_255106178_-3.gif" alt="$i\ge 2$" class="latex-inline" style="vertical-align: -3px" width="36" height="15">,有
<img src="./latex/latex2png-PolyFacZ_84890959_.gif" alt="$$f_i^*=f_i-\sum_{1\le j<i}f_j^*\mu_{ji},\text{其中}\mu_{ji}=\frac{\idea{f_i,f_j^*}}{\idea{f_j^*,f_j^*}}.$$" class="latex-display" width="580" height="50">
于是存在一个上三角阵<img src="./latex/latex2png-PolyFacZ_123475842_-5.gif" alt="$M=(\mu_{ij})$" class="latex-inline" style="vertical-align: -5px" width="73" height="18">,其对角元为1,使得
<img src="./latex/latex2png-PolyFacZ_87112049_.gif" alt="$$(f_1,\ldots,f_n)=(f_1^*,\ldots,f_n^*)M,$$" class="latex-display" width="580" height="18">
其中<img src="./latex/latex2png-PolyFacZ_150178154_-4.gif" alt="$f_i^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">张成同样的空间,且两两互相正交.由正交化的几何意义我们可以很明显地看到,每个向量的长度都不大于原向量的长度,即基向量的长度缩短了.但是光作GSO(Gram-Schmidt orthogonalization)是不行的,因为正交化后所得的向量并不一定是原先格子中的向量,这是模和线性空间的不同.但是首先，我们有下面的估计：</p>

<div class="lemma">
<span class="theorem-header">引理5<a name=""></a></span><span class="theorem-name"></span>
设<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">为由<img src="./latex/latex2png-PolyFacZ_70449430_-5.gif" alt="$(f_1,\ldots,f_n)$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">生成的<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">-模,<img src="./latex/latex2png-PolyFacZ_95642013_-5.gif" alt="$(f_1^*,\ldots,f_n^*)$" class="latex-inline" style="vertical-align: -5px" width="82" height="18">是对其进行GSO所得的基,则对任意非零向量<img src="./latex/latex2png-PolyFacZ_129065902_-4.gif" alt="$f\in L$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">,我们有<img src="./latex/latex2png-PolyFacZ_140332917_.gif" alt="$$\|f\|\ge\min\{\|f_1^*\|,\ldots,\|f_n^*\|\}.$$" class="latex-display" width="580" height="18">


</div>

<div class="proof">
<span class="proof-header">证明</span>
由GSO过程知道有对角元为1的上三角阵<img src="./latex/latex2png-PolyFacZ_123475842_-5.gif" alt="$M=(\mu_{ij})$" class="latex-inline" style="vertical-align: -5px" width="73" height="18">满足<img src="./latex/latex2png-PolyFacZ_87112049_.gif" alt="$$(f_1,\ldots,f_n)=(f_1^*,\ldots,f_n^*)M,$$" class="latex-display" width="580" height="18"> 则<img src="./latex/latex2png-PolyFacZ_183667858_-9.gif" alt="$f_i=\sum_{1\le j\le n}f_j^*\mu_{ji}=\sum_{1\le j\le i}f_j^*\mu_{ji}$" class="latex-inline" style="vertical-align: -9px" width="257" height="22">.对于非零向量<img src="./latex/latex2png-PolyFacZ_129065902_-4.gif" alt="$f\in L$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">,存在<img src="./latex/latex2png-PolyFacZ_12018526_-3.gif" alt="$k\le n$" class="latex-inline" style="vertical-align: -3px" width="41" height="15">使得<img src="./latex/latex2png-PolyFacZ_223613235_.gif" alt="$$f=\sum_{1\le i\le k}\lambda_if_i,\quad \lambda_k\neq 0,\lambda_1\cdots\lambda_k\in\mathbb{Z}.$$" class="latex-display" width="580" height="41">

<p>于是<img src="./latex/latex2png-PolyFacZ_194332485_-9.gif" alt="$f=\sum_{1\le i\le k}\lambda_if_i=\sum_{1\le i\le k}\lambda_i\sum_{1\le j\le i}f_j^*\mu_{ji}=\lambda_kf_k^*+\sum_{1\le i<k}\gamma_if_i^*$" class="latex-inline" style="vertical-align: -9px" width="488" height="22">,其中<img src="./latex/latex2png-PolyFacZ_35211872_-4.gif" alt="$\gamma_i\in\mathbb{R}$" class="latex-inline" style="vertical-align: -4px" width="46" height="16">,将此式代入<img src="./latex/latex2png-PolyFacZ_68581043_-5.gif" alt="$\|f\|$" class="latex-inline" style="vertical-align: -5px" width="24" height="18">可得：
<img src="./latex/latex2png-PolyFacZ_95035342_.gif" alt="
\begin{align*}
\|f\|^2&=(\lambda_kf_k^*+\sum_{1\le i<k}\gamma_if_i^*)(\lambda_kf_k^*+\sum_{1\le i<k}\gamma_if_i^*)\\
&=\lambda_k^2\|f_k^*\|^2+\sum_{1\le i<k}\gamma_i^2\|f_i^*\|^2\ge\lambda_k^2\|f_k^*\|^2\\
&\ge\|f_k^*\|^2\ge\min\{\|f_1^*\|^2,\ldots,\|f_n^*\|^2\},
\end{align*}
" class="latex-display" width="580" height="119">
证毕.
<span class="proof-end">□</span></p>

</div>

<p>既然我们用GSO得到的不一定是格的约化基,那么我们可以放宽条件,下面给出一种约化基的定义方式：</p>

<div class="definition">
<span class="theorem-header">定义4<a name=""></a></span><span class="theorem-name"></span>
设<img src="./latex/latex2png-PolyFacZ_141358507_-4.gif" alt="$f_1,\ldots,f_n\in\mathbb{R}^n$" class="latex-inline" style="vertical-align: -4px" width="109" height="16">线性无关且<img src="./latex/latex2png-PolyFacZ_95642013_-5.gif" alt="$(f_1^*,\ldots,f_n^*)$" class="latex-inline" style="vertical-align: -5px" width="82" height="18">是其对应的GS正交基.则称<img src="./latex/latex2png-PolyFacZ_70449430_-5.gif" alt="$(f_1,\ldots,f_n)$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">是约化基，如果对于<img src="./latex/latex2png-PolyFacZ_87024785_-3.gif" alt="$1\le i<n$" class="latex-inline" style="vertical-align: -3px" width="67" height="15">有<img src="./latex/latex2png-PolyFacZ_5839938_-6.gif" alt="$\|f_i^*\|^2\le 2\|f_{i+1}^*\|^2$" class="latex-inline" style="vertical-align: -6px" width="124" height="20">且对于<img src="./latex/latex2png-PolyFacZ_158237114_-5.gif" alt="$\mu_{ji}$" class="latex-inline" style="vertical-align: -5px" width="21" height="13">的非零元均有<img src="./latex/latex2png-PolyFacZ_143915942_-5.gif" alt="$|\mu_{ji}|<1/2$" class="latex-inline" style="vertical-align: -5px" width="76" height="18">.


</div>

<div class="theorem">
<span class="theorem-header">定理5<a name=""></a></span><span class="theorem-name"></span>
设<img src="./latex/latex2png-PolyFacZ_70449430_-5.gif" alt="$(f_1,\ldots,f_n)$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">是其所生成的格子<img src="./latex/latex2png-PolyFacZ_67850854_-1.gif" alt="$\in\mathbb{R}^n$" class="latex-inline" style="vertical-align: -1px" width="35" height="13">的约化基且<img src="./latex/latex2png-PolyFacZ_117799002_-5.gif" alt="$f\in L\setminus\{0\}$" class="latex-inline" style="vertical-align: -5px" width="79" height="18">,则<img src="./latex/latex2png-PolyFacZ_37075396_-5.gif" alt="$\|f_1\|\le 2^{(n-1)/2}\|f\|$" class="latex-inline" style="vertical-align: -5px" width="137" height="20">.


</div>

<div class="proof">
<span class="proof-header">证明</span>由于
<img src="./latex/latex2png-PolyFacZ_37829078_.gif" alt="$$\|f_1\|^2=\|f_1^*\|^2\le 2\|f_2^*\|^2\le 2^2\|f_3^*\|^2\le\cdots\le 2^{n-1}\|f_n^*\|^2$$" class="latex-display" width="580" height="20">
可设<img src="./latex/latex2png-PolyFacZ_20134518_-5.gif" alt="$\|f_m^*\|=\min\{\|f_1^*\|,\ldots,\|f_n^*\|\}$" class="latex-inline" style="vertical-align: -5px" width="206" height="18">,则
<img src="./latex/latex2png-PolyFacZ_203172424_.gif" alt="$$2^{n-1}\|f\|^2\ge 2^{n-1}\|f_m^*\|^2\ge 2^{m-1}\|f_m^*\|^2\ge\|f_1^*\|^2=\|f_1\|^2,$$" class="latex-display" width="580" height="20">
于是命题得证.
<span class="proof-end">□</span>

</div>

<p>下面给出生成约化基的算法：
<div class="algorithm">
<span class="theorem-header">算法6<a name="al:basereduction"></a></span><span class="theorem-name">(约化基算法)</span></p>

<p>输入：线性无关的向量<img src="./latex/latex2png-PolyFacZ_141358508_-4.gif" alt="$f_1,\ldots,f_n\in\mathbb{Z}^n$" class="latex-inline" style="vertical-align: -4px" width="108" height="16">,</p>

<p>输出：由输入向量所生成的<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">-模的约化基<img src="./latex/latex2png-PolyFacZ_197985770_-5.gif" alt="$(g_1,\ldots,g_n)$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">.</p>

<ol>
<li>将<img src="./latex/latex2png-PolyFacZ_121677938_-4.gif" alt="$g_1,\ldots,g_n$" class="latex-inline" style="vertical-align: -4px" width="68" height="12">初始化为<img src="./latex/latex2png-PolyFacZ_104900706_-4.gif" alt="$f_1,\ldots,f_n$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">,并进行相应的GSO过程,得到约化基<img src="./latex/latex2png-PolyFacZ_115094118_-5.gif" alt="$G^*=(g_1^*,\ldots,g_n^*)$" class="latex-inline" style="vertical-align: -5px" width="123" height="18">和变换矩阵<img src="./latex/latex2png-PolyFacZ_169423336_-3.gif" alt="$M\in\mathbb{Q}^{n\times n}$" class="latex-inline" style="vertical-align: -3px" width="77" height="15">使得<img src="./latex/latex2png-PolyFacZ_252732221_-1.gif" alt="$G=G^*M$" class="latex-inline" style="vertical-align: -1px" width="73" height="13">,<img src="./latex/latex2png-PolyFacZ_84177940_0.gif" alt="$i=2$" class="latex-inline" style="vertical-align: 0px" width="36" height="12">,</li>

<li>当<img src="./latex/latex2png-PolyFacZ_12018558_-3.gif" alt="$i\le n$" class="latex-inline" style="vertical-align: -3px" width="38" height="15">时,执行下面3～5步,</li>

<li>让<img src="./latex/latex2png-PolyFacZ_42234898_-4.gif" alt="$j$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">从<img src="./latex/latex2png-PolyFacZ_67335188_0.gif" alt="$i-1$" class="latex-inline" style="vertical-align: 0px" width="33" height="12">循环到<img src="./latex/latex2png-PolyFacZ_41120786_0.gif" alt="$1$" class="latex-inline" style="vertical-align: 0px" width="6" height="11">，执行下面4步,</li>

<li><img src="./latex/latex2png-PolyFacZ_94530665_-5.gif" alt="$g_i=g_i-g_j\lceil\mu_{ji}\rfloor$" class="latex-inline" style="vertical-align: -5px" width="118" height="18">(此处取最接近<img src="./latex/latex2png-PolyFacZ_158237114_-5.gif" alt="$\mu_{ji}$" class="latex-inline" style="vertical-align: -5px" width="21" height="13">的整数),重新计算GSO得到<img src="./latex/latex2png-PolyFacZ_218919956_-1.gif" alt="$G^*$" class="latex-inline" style="vertical-align: -1px" width="18" height="13">,<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">,</li>

<li>若<img src="./latex/latex2png-PolyFacZ_85160980_-1.gif" alt="$i>1$" class="latex-inline" style="vertical-align: -1px" width="35" height="13">且<img src="./latex/latex2png-PolyFacZ_82821300_-5.gif" alt="$\|g_{i-1}^*\|^2>2\|g_i^*\|^2$" class="latex-inline" style="vertical-align: -5px" width="122" height="19">则交换<img src="./latex/latex2png-PolyFacZ_6945113_-4.gif" alt="$g_{i-1}$" class="latex-inline" style="vertical-align: -4px" width="29" height="12">和<img src="./latex/latex2png-PolyFacZ_87258132_-4.gif" alt="$g_i$" class="latex-inline" style="vertical-align: -4px" width="13" height="12">,并重新计算GSO得到<img src="./latex/latex2png-PolyFacZ_218919956_-1.gif" alt="$G^*$" class="latex-inline" style="vertical-align: -1px" width="18" height="13">,<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">,<img src="./latex/latex2png-PolyFacZ_201099625_0.gif" alt="$i=i-1$" class="latex-inline" style="vertical-align: 0px" width="61" height="12">,否则<img src="./latex/latex2png-PolyFacZ_203196777_-2.gif" alt="$i=i+1$" class="latex-inline" style="vertical-align: -2px" width="61" height="14">,</li>

<li>输出<img src="./latex/latex2png-PolyFacZ_197985770_-5.gif" alt="$(g_1,\ldots,g_n)$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">.</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注5<a name=""></a></span><span class="theorem-name"></span>
也可以由GSO过程求得变换矩阵<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">使得<img src="./latex/latex2png-PolyFacZ_170569891_-5.gif" alt="$(f_1^*,\ldots,f_n^*)=(f_1,\ldots,f_n)M$" class="latex-inline" style="vertical-align: -5px" width="206" height="18">,再将<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">中元素均取整后代替算法<a class="ref-th" href="#al:basereduction">6</a>第4步中的计算.下面举的几个例子用此算法,当然算法<a class="ref-th" href="#al:basereduction">6</a>中的矩阵<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">更好计算一些.


</div>

<div class="problem">
<span class="proof-header">例4<a name="example:basereduction1"></a></span><span class="theorem-name"></span>
记<img src="./latex/latex2png-PolyFacZ_126892862_-1.gif" alt="$a=219914302784468853031851163930189578018051741$" class="latex-inline" style="vertical-align: -1px" width="402" height="13">,<img src="./latex/latex2png-PolyFacZ_163534021_-1.gif" alt="$b=5^{64}$" class="latex-inline" style="vertical-align: -1px" width="50" height="15">,设<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">由<img src="./latex/latex2png-PolyFacZ_4491651_-5.gif" alt="$(1,a)$" class="latex-inline" style="vertical-align: -5px" width="35" height="18">和<img src="./latex/latex2png-PolyFacZ_264992381_-5.gif" alt="$(0,b)$" class="latex-inline" style="vertical-align: -5px" width="33" height="18">生成,用上面的算法求其约化基.
<span class="example-end">◇</span>

</div>

<div class="solution">
<span class="proof-header">解</span>
编程可得如下约化基：<img src="./latex/latex2png-PolyFacZ_98938089_.gif" alt="$$g_1=(-6999570441183108942993, -13384313532767302775813),$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_249616318_.gif" alt="$$g_2=(-32538542807519884274273, 15228795581564048106332),$$" class="latex-display" width="580" height="18"> 其中<img src="./latex/latex2png-PolyFacZ_93856007_.gif" alt="$$g_1=-6999570441183108942993(1,a)+2839517743881186811624(0,b).$$" class="latex-display" width="580" height="18">

<p>我们取<img src="./latex/latex2png-PolyFacZ_182060768_-4.gif" alt="$g^*=g_1$" class="latex-inline" style="vertical-align: -4px" width="52" height="16">作为短矢量,有<img src="./latex/latex2png-PolyFacZ_85402982_.gif" alt="$$g^*=-6999570441183108942993x-13384313532767302775813.$$" class="latex-display" width="580" height="17"></p>

<p>如果我们再考虑由<img src="./latex/latex2png-PolyFacZ_246789552_-5.gif" alt="$(1,a,0),(0,1,a),(0,0,b)$" class="latex-inline" style="vertical-align: -5px" width="170" height="18">生成的<img src="./latex/latex2png-PolyFacZ_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">-模,则按照算法可得如下约化基：<img src="./latex/latex2png-PolyFacZ_125514010_.gif" alt="$$g_1=(4, 5, 6),$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_134389260_.gif" alt="$$g_2=(5989804332598408382848, 487684974564901535567,-4399607033869690201541),$$" class="latex-display" width="580" height="18"> <img src="./latex/latex2png-PolyFacZ_126966139_.gif" alt="$$g_3=(-3921135160431868252895, 6733001971931690223946,-2996744869655163018019),$$" class="latex-display" width="580" height="18"> 其中
<img src="./latex/latex2png-PolyFacZ_201890695_.gif" alt="
\begin{align*}
g_1&=4(1,a,0)-879657211137875412127404655720758312072206959(0,1,a)\\
&+356850792566185450269524416969136119168940313(0,0,b),
\end{align*}
" class="latex-display" width="580" height="49"></p>

<p>此时得到短矢量<img src="./latex/latex2png-PolyFacZ_252586011_-4.gif" alt="$g^*=4x^2+5x+6$" class="latex-inline" style="vertical-align: -4px" width="130" height="18">.</p>


</div>


<h3><a name="sec7" id="sec7"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>约化基算法的一些细节说明</h3>

<p class="first">对于约化基算法<a class="ref-th" href="#al:basereduction">6</a>,它应该是一种说明性质的,实际使用它时有些效率上的不足.例如仔细分析一下我们会发现该算法第4步中的GSO更新是不必要的,可以将这一步省去.而且在每一步交换两个基向量时对GSO的更新也是有很多冗余计算的.当我们采用本节介绍的算法后,我们可以发现它甚至能比原算法效率提高一百倍.</p>

<p>事实上,关于格的约化基的定义方式在各文献中不一致,上节所提的定义方式是文献<span class="cite"><a class="cite" href="#ref-1" name="cite-1">[1]</a></span>给出的.A. K. Lenstra, H. W. Lenstra和L. Lov&aacute;sz的文献<span class="cite"><a class="cite" href="#ref-3" name="cite-3">[3]</a></span>中就给出了如下定义:</p>

<div class="definition">
<span class="theorem-header">定义5<a name=""></a></span><span class="theorem-name"></span>
设<img src="./latex/latex2png-PolyFacZ_141358507_-4.gif" alt="$f_1,\ldots,f_n\in\mathbb{R}^n$" class="latex-inline" style="vertical-align: -4px" width="109" height="16">线性无关且<img src="./latex/latex2png-PolyFacZ_95642013_-5.gif" alt="$(f_1^*,\ldots,f_n^*)$" class="latex-inline" style="vertical-align: -5px" width="82" height="18">是其对应的GS正交基,并且记<img src="./latex/latex2png-PolyFacZ_133824157_-7.gif" alt="$\mu_{ij}=\idea{f_i,f_j^*}/\idea{f_j^*,f_j^*}$" class="latex-inline" style="vertical-align: -7px" width="158" height="20">则称<img src="./latex/latex2png-PolyFacZ_70449430_-5.gif" alt="$(f_1,\ldots,f_n)$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">是约化基,如果满足以下条件:

<ol>
<li><img src="./latex/latex2png-PolyFacZ_113677444_-5.gif" alt="$|\mu_{ij}|\le 1/2,\forall 1\le j<i\le n$" class="latex-inline" style="vertical-align: -5px" width="192" height="18">,</li>

<li><img src="./latex/latex2png-PolyFacZ_223786878_-6.gif" alt="$|f_i^*+\mu_{i,i-1}f_{i-1}^*|^2\ge\frac{3}{4}|f_{i-1}^*|^2,\forall 1<i\le n$" class="latex-inline" style="vertical-align: -6px" width="290" height="21">.</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注6<a name=""></a></span><span class="theorem-name"></span>
这里关于矩阵元<img src="./latex/latex2png-PolyFacZ_173965754_-5.gif" alt="$\mu_{ij}$" class="latex-inline" style="vertical-align: -5px" width="21" height="13">的定义可能和上节有点不一样,这是上节将<img src="./latex/latex2png-PolyFacZ_70480916_-4.gif" alt="$f_i$" class="latex-inline" style="vertical-align: -4px" width="12" height="16">视为列向量,而本节视为行向量,只是叙述语言的不同,并无本质差别.


</div>

<p>从定义中我们明显看出,本节定义的约化基一定是上一节定义的约化基,其条件更强,因此对后面的算法是没有影响的.下面我们给出新的约化基算法,它在细节处理比前节的算法要节省很多计算.</p>

<div class="algorithm">
<span class="theorem-header">算法7<a name="al:basereduction2"></a></span><span class="theorem-name">(约化基算法)</span>
输入输出同算法<a class="ref-th" href="#al:basereduction">6</a>.

<ol>
<li>初始化工作.首先将各<img src="./latex/latex2png-PolyFacZ_87258132_-4.gif" alt="$g_i$" class="latex-inline" style="vertical-align: -4px" width="13" height="12">初化为<img src="./latex/latex2png-PolyFacZ_70480916_-4.gif" alt="$f_i$" class="latex-inline" style="vertical-align: -4px" width="12" height="16">,并且<img src="./latex/latex2png-PolyFacZ_42169362_0.gif" alt="$i$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">顺次由1循环到<img src="./latex/latex2png-PolyFacZ_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">,做如下步骤2至4,</li>

<li><img src="./latex/latex2png-PolyFacZ_138892512_-4.gif" alt="$g_i^*=g_i$" class="latex-inline" style="vertical-align: -4px" width="51" height="16">,</li>

<li>将<img src="./latex/latex2png-PolyFacZ_42234898_-4.gif" alt="$j$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">顺次由1循环到<img src="./latex/latex2png-PolyFacZ_67335188_0.gif" alt="$i-1$" class="latex-inline" style="vertical-align: 0px" width="33" height="12">,计算<img src="./latex/latex2png-PolyFacZ_97531537_-7.gif" alt="$\mu_{ij}=\idea{g_i,g_j^*}/G_j$" class="latex-inline" style="vertical-align: -7px" width="120" height="20">,<img src="./latex/latex2png-PolyFacZ_217051163_-7.gif" alt="$g_i^*=g_i^*-\mu_{ij}g_j^*$" class="latex-inline" style="vertical-align: -7px" width="111" height="19">,</li>

<li><img src="./latex/latex2png-PolyFacZ_143823328_-5.gif" alt="$G_i=\idea{g_i^*,g_i^*}$" class="latex-inline" style="vertical-align: -5px" width="91" height="18">,</li>

<li><img src="./latex/latex2png-PolyFacZ_117732372_0.gif" alt="$k=2$" class="latex-inline" style="vertical-align: 0px" width="39" height="12">,并循环做下面6-10步,</li>

<li>将<img src="./latex/latex2png-PolyFacZ_42365970_0.gif" alt="$l$" class="latex-inline" style="vertical-align: 0px" width="4" height="12">顺次由<img src="./latex/latex2png-PolyFacZ_100889620_0.gif" alt="$k-1$" class="latex-inline" style="vertical-align: 0px" width="36" height="12">递减到<img src="./latex/latex2png-PolyFacZ_41120786_0.gif" alt="$1$" class="latex-inline" style="vertical-align: 0px" width="6" height="11">,做如下7-8步,</li>

<li>若<img src="./latex/latex2png-PolyFacZ_143911078_-5.gif" alt="$|\mu_{kl}|>1/2$" class="latex-inline" style="vertical-align: -5px" width="77" height="18">,则
<img src="./latex/latex2png-PolyFacZ_222173985_.gif" alt="$$r=\lfloor\mu_{kl}\rceil,g_k=g_k-rg_l,$$" class="latex-display" width="580" height="18">
对<img src="./latex/latex2png-PolyFacZ_114040737_-4.gif" alt="$j=1,2,\ldots,l-1$" class="latex-inline" style="vertical-align: -4px" width="124" height="16">顺次计算<img src="./latex/latex2png-PolyFacZ_71629368_-5.gif" alt="$\mu_{kj}=\mu_{kj}-r\mu_{lj}$" class="latex-inline" style="vertical-align: -5px" width="119" height="13">,并且<img src="./latex/latex2png-PolyFacZ_197783557_-4.gif" alt="$\mu_{kl}=\mu_{kl}-r$" class="latex-inline" style="vertical-align: -4px" width="94" height="12">,</li>

<li>若<img src="./latex/latex2png-PolyFacZ_167545190_0.gif" alt="$l=k-1$" class="latex-inline" style="vertical-align: 0px" width="64" height="12">则检验<img src="./latex/latex2png-PolyFacZ_105554062_-8.gif" alt="$G_k<(\frac{3}{4}-\mu_{k,k-1}^2)G_{k-1}$" class="latex-inline" style="vertical-align: -8px" width="169" height="23">是否成立,若成立则交换<img src="./latex/latex2png-PolyFacZ_87389204_-4.gif" alt="$g_k$" class="latex-inline" style="vertical-align: -4px" width="15" height="12">与<img src="./latex/latex2png-PolyFacZ_6945113_-4.gif" alt="$g_{k-1}$" class="latex-inline" style="vertical-align: -4px" width="29" height="12">并更新此时的各GSO结果,并直接转第6步,</li>

<li>若<img src="./latex/latex2png-PolyFacZ_119043092_0.gif" alt="$k=n$" class="latex-inline" style="vertical-align: 0px" width="41" height="12">则终止算法并输出<img src="./latex/latex2png-PolyFacZ_197985770_-5.gif" alt="$(g_1,\ldots,g_n)$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">,</li>

<li><img src="./latex/latex2png-PolyFacZ_169642343_-2.gif" alt="$k=k+1$" class="latex-inline" style="vertical-align: -2px" width="68" height="14">.</li>
</ol>


</div>

<p>算法的终止性见<span class="cite"><a class="cite" href="#ref-3" name="cite-3">[3]</a></span>.</p>

<p>本算法仅在初始化时需要计算诸<img src="./latex/latex2png-PolyFacZ_150178153_-4.gif" alt="$g_i^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">,在后面的算法中实际上已不需要它们,只要保存<img src="./latex/latex2png-PolyFacZ_173965754_-5.gif" alt="$\mu_{ij}$" class="latex-inline" style="vertical-align: -5px" width="21" height="13">矩阵以及各<img src="./latex/latex2png-PolyFacZ_150178153_-4.gif" alt="$g_i^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">的模<img src="./latex/latex2png-PolyFacZ_221475860_-2.gif" alt="$G_i$" class="latex-inline" style="vertical-align: -2px" width="17" height="14">即可.在本节的开始,我们也提到了在交换两个基矢时对整个GSO的更新实际上包含了很多不必要的计算,因此本算法第8步所提的到的更新GSO步骤是很重要的,我们在下面给出:</p>

<div class="algorithm">
<span class="theorem-header">算法8<a name="al:basereduction21"></a></span><span class="theorem-name">(约化基算法第八步的更新)</span>
各符号同算法<a class="ref-th" href="#al:basereduction2">7</a>.

<ol>
<li><img src="./latex/latex2png-PolyFacZ_250782701_-5.gif" alt="$\mu=\mu_{k,k-1}$" class="latex-inline" style="vertical-align: -5px" width="77" height="13">,<img src="./latex/latex2png-PolyFacZ_213207878_-4.gif" alt="$G=G_k+\mu^2G_{k-1}$" class="latex-inline" style="vertical-align: -4px" width="130" height="18">,<img src="./latex/latex2png-PolyFacZ_176670698_-5.gif" alt="$\mu_{k,k-1}=\mu G_{k-1}/G$" class="latex-inline" style="vertical-align: -5px" width="138" height="18">,<img src="./latex/latex2png-PolyFacZ_181947937_-5.gif" alt="$G_k=G_{k-1}G_k/G$" class="latex-inline" style="vertical-align: -5px" width="123" height="18">,<img src="./latex/latex2png-PolyFacZ_195476338_-2.gif" alt="$G_{k-1}=G$" class="latex-inline" style="vertical-align: -2px" width="72" height="14">,</li>

<li>交换两个基矢<img src="./latex/latex2png-PolyFacZ_109288333_-5.gif" alt="$(g_{k-1},g_k)=(g_k,g_{k-1})$" class="latex-inline" style="vertical-align: -5px" width="159" height="18">,</li>

<li>对<img src="./latex/latex2png-PolyFacZ_130752417_-4.gif" alt="$j=1,2,\ldots,k-2$" class="latex-inline" style="vertical-align: -4px" width="129" height="16">顺次交换<img src="./latex/latex2png-PolyFacZ_31083489_-5.gif" alt="$(\mu_{k-1,j},\mu_{kj})=(\mu_{kj},\mu_{k-1,j})$" class="latex-inline" style="vertical-align: -5px" width="200" height="18">,</li>

<li>对<img src="./latex/latex2png-PolyFacZ_190064034_-4.gif" alt="$i=k+1,k+2,\ldots,n$" class="latex-inline" style="vertical-align: -4px" width="158" height="16">顺次计算
<img src="./latex/latex2png-PolyFacZ_51846147_.gif" alt="$$\begin{pmatrix}\mu_{i,k-1}\\ \mu_{ik}\end{pmatrix}=\begin{pmatrix}1 &\mu_{k,k-1}\\ 0 &1\end{pmatrix}\begin{pmatrix}0 &1\\ 1 &-\mu\end{pmatrix}\begin{pmatrix}\mu_{i,k-1}\\ \mu_{ik}\end{pmatrix}$$" class="latex-display" width="580" height="50"></li>

<li>若<img src="./latex/latex2png-PolyFacZ_118780948_-1.gif" alt="$k>2$" class="latex-inline" style="vertical-align: -1px" width="39" height="13">则<img src="./latex/latex2png-PolyFacZ_167545191_0.gif" alt="$k=k-1$" class="latex-inline" style="vertical-align: 0px" width="68" height="12">.</li>
</ol>


</div>

<p>关于更新算法的正确性,只需作一些计算即可证明,这里也不验证了,可以参考<span class="cite"><a class="cite" href="#ref-3" name="cite-3">[3]</a></span>P520.</p>



<h2><a name="sec8" id="sec8"></a>
<a href="#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>应用格中短向量的分解算法</h2>

<p class="first">下面以Hensel提升和格中短向量方法为例来说明后者.这里我们先证明一个引理,便于后面算法正确性的证明.</p>

<div class="lemma">
<span class="theorem-header">引理6<a name=""></a></span><span class="theorem-name"></span>
<img src="./latex/latex2png-PolyFacZ_184517328_-4.gif" alt="$p\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -4px" width="41" height="16">是素数,<img src="./latex/latex2png-PolyFacZ_42365970_0.gif" alt="$l$" class="latex-inline" style="vertical-align: 0px" width="4" height="12">是正整数,<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">,<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">,<img src="./latex/latex2png-PolyFacZ_16144738_-5.gif" alt="$u\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="58" height="18">是非零多项式且<img src="./latex/latex2png-PolyFacZ_49924668_-5.gif" alt="$p\not|\mathrm{lc}(f)$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">,<img src="./latex/latex2png-PolyFacZ_242398203_-4.gif" alt="$f\bmod p$" class="latex-inline" style="vertical-align: -4px" width="58" height="16">无平方,<img src="./latex/latex2png-PolyFacZ_75527188_-5.gif" alt="$g|f$" class="latex-inline" style="vertical-align: -5px" width="23" height="18">,<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">是首一非平凡多项式,且<img src="./latex/latex2png-PolyFacZ_161063447_-5.gif" alt="$u|f\bmod p^l$" class="latex-inline" style="vertical-align: -5px" width="77" height="19">,<img src="./latex/latex2png-PolyFacZ_143473669_-5.gif" alt="$u|g\bmod p$" class="latex-inline" style="vertical-align: -5px" width="72" height="18">.则<img src="./latex/latex2png-PolyFacZ_160014871_-5.gif" alt="$u|g\bmod p^l$" class="latex-inline" style="vertical-align: -5px" width="76" height="19">.


</div>

<div class="proof">
<span class="proof-header">证明</span>
令<img src="./latex/latex2png-PolyFacZ_259546085_-5.gif" alt="$h,v,w\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="94" height="18">使得<img src="./latex/latex2png-PolyFacZ_130328386_-5.gif" alt="$f=gh\equiv uw\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="163" height="19">且<img src="./latex/latex2png-PolyFacZ_88841923_-5.gif" alt="$g\equiv uv\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="113" height="18">.<img src="./latex/latex2png-PolyFacZ_242398203_-4.gif" alt="$f\bmod p$" class="latex-inline" style="vertical-align: -4px" width="58" height="16">无平方,则<img src="./latex/latex2png-PolyFacZ_242402299_-4.gif" alt="$g\bmod p$" class="latex-inline" style="vertical-align: -4px" width="58" height="16">也无平方因子,<img src="./latex/latex2png-PolyFacZ_32107885_-5.gif" alt="$\gcd(u\bmod p,v\bmod p)=1\in\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="248" height="18">.由Hensel引理知有<img src="./latex/latex2png-PolyFacZ_217287660_0.gif" alt="$u^*$" class="latex-inline" style="vertical-align: 0px" width="16" height="12">,<img src="./latex/latex2png-PolyFacZ_227321500_-5.gif" alt="$v^*\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">使得<img src="./latex/latex2png-PolyFacZ_188383889_-5.gif" alt="$u^*\equiv u\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="113" height="18">,<img src="./latex/latex2png-PolyFacZ_205226641_-5.gif" alt="$v^*\equiv v\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="111" height="18">且<img src="./latex/latex2png-PolyFacZ_147951676_-5.gif" alt="$g\equiv u^*v^*\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="134" height="19">.于是<img src="./latex/latex2png-PolyFacZ_106857141_-5.gif" alt="$uvh\equiv gh\equiv uw\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="176" height="18">推出<img src="./latex/latex2png-PolyFacZ_22184590_-5.gif" alt="$vh\equiv w\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="117" height="18">.<img src="./latex/latex2png-PolyFacZ_196256568_-5.gif" alt="$v^*h\equiv vh\equiv w\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="165" height="18">且<img src="./latex/latex2png-PolyFacZ_46978434_-5.gif" alt="$u^*(v^*h)\equiv gh=f\equiv uw\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="242" height="19">.再由<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">,<img src="./latex/latex2png-PolyFacZ_43021330_0.gif" alt="$v$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">在模<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">下互素,我们由提升的唯一性知<img src="./latex/latex2png-PolyFacZ_94761757_-5.gif" alt="$u^*\equiv u\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="118" height="19">,<img src="./latex/latex2png-PolyFacZ_256230242_-5.gif" alt="$g\equiv uv^*\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="126" height="19">.
<span class="proof-end">□</span>

</div>

<div class="algorithm">
<span class="theorem-header">算法9<a name="al:shortvectors"></a></span><span class="theorem-name">(整系数因子分解算法4:Hensel提升和格中短向量算法)</span>

<p>输入：一个无平方因子本原<img src="./latex/latex2png-PolyFacZ_211549676_-5.gif" alt="$n(\ge 1)$" class="latex-inline" style="vertical-align: -5px" width="47" height="18">次多项式<img src="./latex/latex2png-PolyFacZ_15161698_-5.gif" alt="$f\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">,<img src="./latex/latex2png-PolyFacZ_68944530_-5.gif" alt="$\mathrm{lc}(f)>0$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">且<img src="./latex/latex2png-PolyFacZ_231597701_-5.gif" alt="$\|f\|_{\infty}=A$" class="latex-inline" style="vertical-align: -5px" width="74" height="18">,</p>

<p>输出：<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的不可约因子<img src="./latex/latex2png-PolyFacZ_21450496_-5.gif" alt="$\{f_1,\ldots,f_k\}\subset\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="135" height="18">.</p>

<ol>
<li>若<img src="./latex/latex2png-PolyFacZ_167998484_0.gif" alt="$n=1$" class="latex-inline" style="vertical-align: 0px" width="39" height="11">则输出<img src="./latex/latex2png-PolyFacZ_199788877_-5.gif" alt="$\{f\}$" class="latex-inline" style="vertical-align: -5px" width="24" height="18">,否则<img src="./latex/latex2png-PolyFacZ_58589541_-5.gif" alt="$b=\mathrm{lc}(f)$" class="latex-inline" style="vertical-align: -5px" width="63" height="18">,<img src="./latex/latex2png-PolyFacZ_73380632_-5.gif" alt="$B=(n+1)^{1/2}2^nA$" class="latex-inline" style="vertical-align: -5px" width="137" height="20">,<img src="./latex/latex2png-PolyFacZ_115985300_-5.gif" alt="$C=(n+1)^{2n}A^{2n-1}$" class="latex-inline" style="vertical-align: -5px" width="144" height="19">,<img src="./latex/latex2png-PolyFacZ_23605766_-5.gif" alt="$\gamma=\lceil 2\log_2C\rceil$" class="latex-inline" style="vertical-align: -5px" width="100" height="18">,</li>

<li>任选素数<img src="./latex/latex2png-PolyFacZ_93355312_-4.gif" alt="$p\le 2\gamma\ln\gamma$" class="latex-inline" style="vertical-align: -4px" width="78" height="16">,<img src="./latex/latex2png-PolyFacZ_66731070_-4.gif" alt="$\overline{f}=f\bmod p$" class="latex-inline" style="vertical-align: -4px" width="91" height="19">,直至<img src="./latex/latex2png-PolyFacZ_25100828_-5.gif" alt="$p\not|b$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">且<img src="./latex/latex2png-PolyFacZ_16859241_-5.gif" alt="$\gcd(\overline{f},\overline{f}')=1\in\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="155" height="23">,再令<img src="./latex/latex2png-PolyFacZ_201728645_-7.gif" alt="$l=\lceil\log_p(2^{n^2}B^{2n})\rceil$" class="latex-inline" style="vertical-align: -7px" width="134" height="24">,</li>

<li>在<img src="./latex/latex2png-PolyFacZ_223283783_-5.gif" alt="$\field{p}[x]$" class="latex-inline" style="vertical-align: -5px" width="35" height="18">上得到分解<img src="./latex/latex2png-PolyFacZ_53262560_-5.gif" alt="$f\equiv bh_1\cdots h_r\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="161" height="18">,各因子无穷范数小于<img src="./latex/latex2png-PolyFacZ_186938388_-5.gif" alt="$p/2$" class="latex-inline" style="vertical-align: -5px" width="25" height="18">且首一,</li>

<li>利用Hensel提升得到分解<img src="./latex/latex2png-PolyFacZ_136560204_-5.gif" alt="$f\equiv bg_1\cdots g_r\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="163" height="19">,各因子不可约且无穷范数小于<img src="./latex/latex2png-PolyFacZ_119830176_-5.gif" alt="$p^l/2$" class="latex-inline" style="vertical-align: -5px" width="30" height="19">,首一,</li>

<li><img src="./latex/latex2png-PolyFacZ_230096074_-5.gif" alt="$T=\{1,\ldots,r\}$" class="latex-inline" style="vertical-align: -5px" width="103" height="18">,<img src="./latex/latex2png-PolyFacZ_172920293_-2.gif" alt="$G=\emptyset$" class="latex-inline" style="vertical-align: -2px" width="42" height="15">,<img src="./latex/latex2png-PolyFacZ_235959958_-4.gif" alt="$f^*=f$" class="latex-inline" style="vertical-align: -4px" width="48" height="16">,</li>

<li>当<img src="./latex/latex2png-PolyFacZ_17741700_-4.gif" alt="$T\neq\emptyset$" class="latex-inline" style="vertical-align: -4px" width="42" height="17">时,做下面7～10步,</li>

<li>在<img src="./latex/latex2png-PolyFacZ_238075521_-5.gif" alt="$\{g_t|t\in T\}$" class="latex-inline" style="vertical-align: -5px" width="71" height="18">中选择次数最大的因子<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">,<img src="./latex/latex2png-PolyFacZ_243828974_-4.gif" alt="$d=\deg u$" class="latex-inline" style="vertical-align: -4px" width="68" height="16">,<img src="./latex/latex2png-PolyFacZ_82801740_-4.gif" alt="$n^*=\deg f^*$" class="latex-inline" style="vertical-align: -4px" width="84" height="16">,对<img src="./latex/latex2png-PolyFacZ_200477551_-4.gif" alt="$d<j\le n^*$" class="latex-inline" style="vertical-align: -4px" width="77" height="16">的<img src="./latex/latex2png-PolyFacZ_42234898_-4.gif" alt="$j$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">循环做下面8、9步,</li>

<li>调用算法<a class="ref-th" href="#al:basereduction">6</a>计算一个短矢量<img src="./latex/latex2png-PolyFacZ_126434030_-4.gif" alt="$g^*\in L$" class="latex-inline" style="vertical-align: -4px" width="47" height="16">,其中<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">为<img src="./latex/latex2png-PolyFacZ_128346482_.gif" alt="$$\{ux^i|0\le i<j-d\}\cup\{p^lx^i|0\le i<d\},$$" class="latex-display" width="580" height="20"></li>

<li>用试除法得到<img src="./latex/latex2png-PolyFacZ_132609281_-1.gif" alt="$S\subset T$" class="latex-inline" style="vertical-align: -1px" width="44" height="13">,其中<img src="./latex/latex2png-PolyFacZ_69126096_-5.gif" alt="$S=\{i\in T|h_i|g^*\bmod p\}$" class="latex-inline" style="vertical-align: -5px" width="175" height="18">,计算<img src="./latex/latex2png-PolyFacZ_74668388_-5.gif" alt="$h^*\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">使得其无穷范数小于<img src="./latex/latex2png-PolyFacZ_119830176_-5.gif" alt="$p^l/2$" class="latex-inline" style="vertical-align: -5px" width="30" height="19">且满足<img src="./latex/latex2png-PolyFacZ_158146780_-8.gif" alt="$h^*\equiv b\prod_{i\in T\setminus S}g_i\pmod{p^l}$" class="latex-inline" style="vertical-align: -8px" width="190" height="22">,若<img src="./latex/latex2png-PolyFacZ_185824427_-5.gif" alt="$\|\mathrm{pp}(g^*)\|_1\|\mathrm{pp}(h^*)\|_1\le B$" class="latex-inline" style="vertical-align: -5px" width="178" height="18">则<img src="./latex/latex2png-PolyFacZ_28858641_-5.gif" alt="$T=T\setminus S$" class="latex-inline" style="vertical-align: -5px" width="73" height="18">,<img src="./latex/latex2png-PolyFacZ_2938495_-5.gif" alt="$G=G\bigcup\{\mathrm{pp}(g^*)\}$" class="latex-inline" style="vertical-align: -5px" width="126" height="18">,<img src="./latex/latex2png-PolyFacZ_262780266_-5.gif" alt="$f^*=\mathrm{pp}(h^*)$" class="latex-inline" style="vertical-align: -5px" width="86" height="18">,<img src="./latex/latex2png-PolyFacZ_145359506_-5.gif" alt="$b=\mathrm{lc}(f^*)$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">,转第6步,</li>

<li><img src="./latex/latex2png-PolyFacZ_145846811_-2.gif" alt="$T=\emptyset$" class="latex-inline" style="vertical-align: -2px" width="42" height="15">,<img src="./latex/latex2png-PolyFacZ_94663300_-5.gif" alt="$G=G\bigcup\{f^*\}$" class="latex-inline" style="vertical-align: -5px" width="97" height="18">,</li>

<li>输出<img src="./latex/latex2png-PolyFacZ_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">.</li>
</ol>


</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法有效性:)</span>
只需证明每次执行第6步时,我们有<img src="./latex/latex2png-PolyFacZ_746932_.gif" alt="$$f^*\equiv b\prod_{i\in T}g_i\pmod{p^l},\quad b=\mathrm{lc}(f^*),\quad f=\pm f^*\prod_{g\in G}g,$$" class="latex-display" width="580" height="40"> 且<img src="./latex/latex2png-PolyFacZ_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">中多项式均不可约.初始时显然满足,假设每次到第7步时均满足,令<img src="./latex/latex2png-PolyFacZ_15227234_-5.gif" alt="$g\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">为<img src="./latex/latex2png-PolyFacZ_67925012_-4.gif" alt="$f^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">的一个不可约因子且<img src="./latex/latex2png-PolyFacZ_143473669_-5.gif" alt="$u|g\bmod p$" class="latex-inline" style="vertical-align: -5px" width="72" height="18">,则由本节开始的引理知<img src="./latex/latex2png-PolyFacZ_160014871_-5.gif" alt="$u|g\bmod p^l$" class="latex-inline" style="vertical-align: -5px" width="76" height="19">.相反地,若<img src="./latex/latex2png-PolyFacZ_16210274_-5.gif" alt="$v\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="57" height="18">是<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的因子且在模<img src="./latex/latex2png-PolyFacZ_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">下能被<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">整除，则<img src="./latex/latex2png-PolyFacZ_49764708_-5.gif" alt="$g|v\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">.我们可以证明第9步中的条件成立当且仅当<img src="./latex/latex2png-PolyFacZ_215854702_-5.gif" alt="$\mathrm{pp}(g^*)\mathrm{pp}(h^*)=\pm f^*$" class="latex-inline" style="vertical-align: -5px" width="147" height="18">,又<img src="./latex/latex2png-PolyFacZ_133921449_-4.gif" alt="$\deg g^*<j$" class="latex-inline" style="vertical-align: -4px" width="73" height="16">,我们知道只要<img src="./latex/latex2png-PolyFacZ_104728814_-4.gif" alt="$j\le\deg g$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">则条件不满足.同样地，第10步能使得上述条件在算法循环结束时也是成立的,如果<img src="./latex/latex2png-PolyFacZ_134444720_-4.gif" alt="$\#T=1$" class="latex-inline" style="vertical-align: -4px" width="54" height="16">且<img src="./latex/latex2png-PolyFacZ_200509803_-4.gif" alt="$g=f^*$" class="latex-inline" style="vertical-align: -4px" width="47" height="16">是不可约的.

<p>假设<img src="./latex/latex2png-PolyFacZ_166951595_-4.gif" alt="$\deg g<n^*$" class="latex-inline" style="vertical-align: -4px" width="75" height="16">,令<img src="./latex/latex2png-PolyFacZ_106842862_-4.gif" alt="$j=1+\deg g$" class="latex-inline" style="vertical-align: -4px" width="95" height="16">.则<img src="./latex/latex2png-PolyFacZ_129065886_-4.gif" alt="$g\in L$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">.于是<img src="./latex/latex2png-PolyFacZ_179543843_-5.gif" alt="$\|g^*\|\le 2^{(j-1)/2}\|g\|<2^nB$" class="latex-inline" style="vertical-align: -5px" width="188" height="20">.再由<img src="./latex/latex2png-PolyFacZ_42365970_0.gif" alt="$l$" class="latex-inline" style="vertical-align: 0px" width="4" height="12">的选择,我们有<img src="./latex/latex2png-PolyFacZ_96330447_.gif" alt="$$\|g^*\|^{j-1}\|g\|^{\deg g^*}<(2^nB)^nB^n\le p^l,$$" class="latex-display" width="580" height="21"> 于是由引理<a class="ref-th" href="#le:shortvectors1">3</a>知<img src="./latex/latex2png-PolyFacZ_252026828_-5.gif" alt="$\gcd(g,g^*)$" class="latex-inline" style="vertical-align: -5px" width="68" height="18">非平凡,由<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">不可约以及<img src="./latex/latex2png-PolyFacZ_153681638_-4.gif" alt="$\deg g^*\le j-1=\deg g$" class="latex-inline" style="vertical-align: -4px" width="161" height="16">得<img src="./latex/latex2png-PolyFacZ_264352527_-5.gif" alt="$g=\pm\mathrm{pp}(g^*)$" class="latex-inline" style="vertical-align: -5px" width="90" height="18">.</p>

<p>令<img src="./latex/latex2png-PolyFacZ_221509670_-5.gif" alt="$h=f^*/g$" class="latex-inline" style="vertical-align: -5px" width="65" height="18">,则由Hensel提升唯一性知在第9步有<img src="./latex/latex2png-PolyFacZ_219887155_-5.gif" alt="$\mathrm{lc}(g)h\equiv h^*\pmod{p^l}$" class="latex-inline" style="vertical-align: -5px" width="152" height="19">.再由<img src="./latex/latex2png-PolyFacZ_119830176_-5.gif" alt="$p^l/2$" class="latex-inline" style="vertical-align: -5px" width="30" height="19">大于<img src="./latex/latex2png-PolyFacZ_217143830_-5.gif" alt="$\|bh\|_{\infty}$" class="latex-inline" style="vertical-align: -5px" width="45" height="18">的Mignotte界bB,于是<img src="./latex/latex2png-PolyFacZ_64856744_-5.gif" alt="$\mathrm{lc}(g)h=h^*,h=\mathrm{pp}(h^*)$" class="latex-inline" style="vertical-align: -5px" width="169" height="18">,且<img src="./latex/latex2png-PolyFacZ_4741927_-5.gif" alt="$f^*=\pm\mathrm{pp}(g^*)\mathrm{pp}(h^*)$" class="latex-inline" style="vertical-align: -5px" width="146" height="18">,算法会到到<img src="./latex/latex2png-PolyFacZ_41972754_-4.gif" alt="$f$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">的不可约因子<img src="./latex/latex2png-PolyFacZ_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">.
<span class="proof-end">□</span></p>

</div>

<div class="problem">
<span class="proof-header">例5<a name=""></a></span><span class="theorem-name"></span>
仍然考虑例<a class="ref-th" href="#example:factorization1">1</a>和例<a class="ref-th" href="#example:factorization2">3</a>中的例子<img src="./latex/latex2png-PolyFacZ_86175106_-5.gif" alt="$f=4x^4+13x^3+28x^2+27x+18\in\mathbb{Z}[x]$" class="latex-inline" style="vertical-align: -5px" width="296" height="19">.
<span class="example-end">◇</span>

</div>

<div class="solution">
<span class="proof-header">解</span>
首先,此时<img src="./latex/latex2png-PolyFacZ_125691987_-5.gif" alt="$l=\log_5(2^{n^2}B^{2n})=48.1266$" class="latex-inline" style="vertical-align: -5px" width="197" height="22">,故需提升6次,我们在例<a class="ref-th" href="#example:factorization2">3</a>的结果上再提升三次,可以得到如下结果：
<img src="./latex/latex2png-PolyFacZ_157157125_.gif" alt="
\begin{align*}
f&\equiv 4(x^2+2x+3)(x+219914302784468853031851163930189578018051741)\\
&(x+186661511897595309720943636396038563766616229)\pmod{5^{64}},
\end{align*}
" class="latex-display" width="580" height="51">
另外由前面例<a class="ref-th" href="#example:factorization2">3</a>结果我们知道<img src="./latex/latex2png-PolyFacZ_261834884_.gif" alt="$$f\equiv 4(x^2+2x-2)(x+1)(x-1)\pmod{5}.$$" class="latex-display" width="580" height="20">

<p>首先<img src="./latex/latex2png-PolyFacZ_67644064_-2.gif" alt="$u=x^2+2x+3$" class="latex-inline" style="vertical-align: -2px" width="115" height="16">,<img src="./latex/latex2png-PolyFacZ_291860_0.gif" alt="$d=2$" class="latex-inline" style="vertical-align: 0px" width="39" height="12">,则<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">的生成元为<img src="./latex/latex2png-PolyFacZ_182114462_.gif" alt="$$\{(1,2,3),(0,5^{64},0),(0,0,5^{64})\}.$$" class="latex-display" width="580" height="20">很显然<img src="./latex/latex2png-PolyFacZ_257810257_-5.gif" alt="$(1,2,3)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">应该是一个短向量,由试除法得到<img src="./latex/latex2png-PolyFacZ_119147331_-5.gif" alt="$S=\{1\}$" class="latex-inline" style="vertical-align: -5px" width="55" height="18">,<img src="./latex/latex2png-PolyFacZ_10305245_-8.gif" alt="$h^*=4\prod_{i=2,3}g_i\bmod 5^{64}=4x^2+5x+6$" class="latex-inline" style="vertical-align: -8px" width="292" height="22">,显然满足条件,得到一个不可约因子<img src="./latex/latex2png-PolyFacZ_217131680_-2.gif" alt="$x^2+2x+3$" class="latex-inline" style="vertical-align: -2px" width="83" height="16">,此时<img src="./latex/latex2png-PolyFacZ_252586012_-4.gif" alt="$f^*=4x^2+5x+6$" class="latex-inline" style="vertical-align: -4px" width="130" height="18">,<img src="./latex/latex2png-PolyFacZ_33131500_0.gif" alt="$b=4$" class="latex-inline" style="vertical-align: 0px" width="37" height="12">.此时我们再取因子<img src="./latex/latex2png-PolyFacZ_11304704_.gif" alt="$$u=x+219914302784468853031851163930189578018051741,$$" class="latex-display" width="580" height="16"> <img src="./latex/latex2png-PolyFacZ_226324_0.gif" alt="$d=1$" class="latex-inline" style="vertical-align: 0px" width="38" height="12">,<img src="./latex/latex2png-PolyFacZ_235173534_0.gif" alt="$n^*=2$" class="latex-inline" style="vertical-align: 0px" width="48" height="12">,<img src="./latex/latex2png-PolyFacZ_42234898_-4.gif" alt="$j$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">只能取<img src="./latex/latex2png-PolyFacZ_41186322_0.gif" alt="$2$" class="latex-inline" style="vertical-align: 0px" width="8" height="11">,则得到<img src="./latex/latex2png-PolyFacZ_42890258_0.gif" alt="$L$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">的生成元<img src="./latex/latex2png-PolyFacZ_230899030_-5.gif" alt="$\{u,(0,5^{64})\}$" class="latex-inline" style="vertical-align: -5px" width="82" height="19">,由例<a class="ref-th" href="#example:basereduction1">4</a>得到<img src="./latex/latex2png-PolyFacZ_87500134_.gif" alt="$$g^*=-6999570441183108942993x-13384313532767302775813,$$" class="latex-display" width="580" height="17"> <img src="./latex/latex2png-PolyFacZ_84702228_-4.gif" alt="$g^*$" class="latex-inline" style="vertical-align: -4px" width="15" height="16">是本原的且是<img src="./latex/latex2png-PolyFacZ_162381569_-5.gif" alt="$g^*\equiv 2x+2\pmod{5}$" class="latex-inline" style="vertical-align: -5px" width="149" height="18">,由试除法知<img src="./latex/latex2png-PolyFacZ_135924547_-5.gif" alt="$S=\{2\}$" class="latex-inline" style="vertical-align: -5px" width="55" height="18">,但此时已有<img src="./latex/latex2png-PolyFacZ_111772718_-5.gif" alt="$\|g^*\|_1>B$" class="latex-inline" style="vertical-align: -5px" width="74" height="18">,故此时无解，循环结束，第二个不可约因子为此时的<img src="./latex/latex2png-PolyFacZ_252586012_-4.gif" alt="$f^*=4x^2+5x+6$" class="latex-inline" style="vertical-align: -4px" width="130" height="18">.</p>

<p>其实我们第一步如果不取最大次数的<img src="./latex/latex2png-PolyFacZ_42955794_0.gif" alt="$u$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">,可以对短向量方法有更深的体会.若取<img src="./latex/latex2png-PolyFacZ_182159709_-4.gif" alt="$u=g_2$" class="latex-inline" style="vertical-align: -4px" width="46" height="12">,当<img src="./latex/latex2png-PolyFacZ_101020692_-4.gif" alt="$j=3$" class="latex-inline" style="vertical-align: -4px" width="39" height="16">时则由例<a class="ref-th" href="#example:basereduction1">4</a>后面的讨论可知此时得到短向量<img src="./latex/latex2png-PolyFacZ_252586011_-4.gif" alt="$g^*=4x^2+5x+6$" class="latex-inline" style="vertical-align: -4px" width="130" height="18">.</p>


</div>



<h4 class="ref">参考文献</h4><p class="ref"><a class="ref" href="#cite-1" name="ref-1">[1]</a><span class="ref-author">Joachim von zur Gathen and J&uuml;rgen Gerhard, </span><span class="ref-title">Modern Computer Algebra, </span><span class="ref-publisher">Cambridge University Press, </span><span class="ref-year">2002. </span></p>
<p class="ref"><a class="ref" href="#cite-2" name="ref-2">[2]</a><span class="ref-author">张贤科，许甫华, </span><span class="ref-title-chs">高等代数学, </span><span class="ref-publisher">清华大学出版社, </span><span class="ref-address">北京, </span><span class="ref-year">2004. </span></p>
<p class="ref"><a class="ref" href="#cite-3" name="ref-3">[3]</a><span class="ref-author">A. K. Lenstra and H. W. Lenstra and L. Lov&aacute;sz, </span><span class="ref-title">Factoring Polynomials with Rational Coefficients, </span><span class="ref-journal">Mathematicsche Annaln </span><span class="ref-year">(1982), </span><span class="ref-number">no.261, </span><span class="ref-pages">515-534. </span></p>
<!-- Page published by Emacs Muse ends here -->
      </div><!-- page -->
    </div><!-- left -->
    <div id="bottomshadow"></div><!-- bottom -->
  </div><!-- body -->
  <div id="links">
    <h4>文档列表</h4>
<a href="../doc/Arithmetic.html">高精度运算</a>
<a href="../doc/PrimeTest.html">素数判定</a>
<a href="../doc/IntegerFactorization.html">整数因子分解</a>
<a href="../doc/NumberTheory.html">基础数论算法</a>
<a href="../doc/Constant.html">数学常数</a>
<a href="../doc/ElementaryFunction.html">初等函数</a>
<a href="../doc/BasicConceptsNLA.html">数值线性代数基础</a>
<a href="../doc/MatrixMultiplication.html">矩阵乘法</a>
<a href="../doc/GaussElimination.html">线性方程组与Gauss消元法</a>
<a href="../doc/SpecialLinearEquation.html">特殊线形方程组</a>
<a href="../doc/QRLS.html">正交化与最小二乘法</a>
<a href="../doc/EigenvalueProblem.html">非对称特征值问题</a>
<a href="../doc/SymmetricEigenvalueProblem.html">对称特征值问题</a>
<a href="../doc/MatrixFunction.html">矩阵函数</a>
<a href="../doc/IterationMethods.html">稀疏矩阵中的迭代法</a>
<a href="../doc/ExactLinearAlgebra.html">精确线性代数</a>
<a href="../doc/PolyEval.html">一元多项式求值和插值</a>
<a href="../doc/PolyGCD.html">一元多项式的最大公因子</a>
<a href="../doc/PolyFacZp.html">多项式因子分解(有限域)</a>
<a href="../doc/PolyFacZ.html">多项式因子分解(Z[x])</a>
<a href="../doc/MultiPoly.html">多元多项式最大公因子及因子分解</a>
<a href="../doc/FindRoot.html">一元代数方程求解</a>
<a href="../doc/EqSolving.html">代数方程组求解</a>
<a href="../doc/Summation.html">符号求和</a>
<a href="../doc/Integration.html">符号积分</a>
<a href="../doc/DifferentialEquation.html">微分方程符号解</a>
  </div><!-- links -->
    <div class="navfoot">
      <hr>
      <table width="100%" border="0" summary="Footer navigation">
	<tr>
	  <td width="33%" align="left">
	    <span class="footdate">最后更新：
			2009年03月18日 16:39:38
		</span>
	  </td>
	  <td width="34%" align="center">
	    <span class="foothome">
	      <a href="../index.html">返回主页</a> / <a href="../RecentChanges.html">更新记录</a> /  <a href="http://cn.creativecommons.org/index.php/licenses/licenses_exp">许可协议</a>
	    </span>
	  </td>
	  <td width="33%" align="right">
	    <span class="footcopy">Copyright &copy; 2007,2008 <a href="../JoinUs.html#contact">maTH&mu; Project Group</a></span>
	  </td>
	</tr>
      </table>
  </div><!-- nav -->
</div><!-- container -->
<p align="center">
<script language="javascript" type="text/javascript" src="http://js.users.51.la/2320853.js"></script></p>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-6285506-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
  </body>
</html>